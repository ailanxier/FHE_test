// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/openfhe_bgv.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_proto_2fopenfhe_5fbgv_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_proto_2fopenfhe_5fbgv_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_proto_2fopenfhe_5fbgv_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_proto_2fopenfhe_5fbgv_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_proto_2fopenfhe_5fbgv_2eproto;
namespace OpenFHE {
class APISequence;
struct APISequenceDefaultTypeInternal;
extern APISequenceDefaultTypeInternal _APISequence_default_instance_;
class APISequence_OneAPI;
struct APISequence_OneAPIDefaultTypeInternal;
extern APISequence_OneAPIDefaultTypeInternal _APISequence_OneAPI_default_instance_;
class APISequence_OneAPI_AddManyList;
struct APISequence_OneAPI_AddManyListDefaultTypeInternal;
extern APISequence_OneAPI_AddManyListDefaultTypeInternal _APISequence_OneAPI_AddManyList_default_instance_;
class APISequence_OneAPI_AddTwoList;
struct APISequence_OneAPI_AddTwoListDefaultTypeInternal;
extern APISequence_OneAPI_AddTwoListDefaultTypeInternal _APISequence_OneAPI_AddTwoList_default_instance_;
class APISequence_OneAPI_MulManyList;
struct APISequence_OneAPI_MulManyListDefaultTypeInternal;
extern APISequence_OneAPI_MulManyListDefaultTypeInternal _APISequence_OneAPI_MulManyList_default_instance_;
class APISequence_OneAPI_MulTwoList;
struct APISequence_OneAPI_MulTwoListDefaultTypeInternal;
extern APISequence_OneAPI_MulTwoListDefaultTypeInternal _APISequence_OneAPI_MulTwoList_default_instance_;
class APISequence_OneAPI_RotateOneList;
struct APISequence_OneAPI_RotateOneListDefaultTypeInternal;
extern APISequence_OneAPI_RotateOneListDefaultTypeInternal _APISequence_OneAPI_RotateOneList_default_instance_;
class APISequence_OneAPI_SubTwoList;
struct APISequence_OneAPI_SubTwoListDefaultTypeInternal;
extern APISequence_OneAPI_SubTwoListDefaultTypeInternal _APISequence_OneAPI_SubTwoList_default_instance_;
class EvalData;
struct EvalDataDefaultTypeInternal;
extern EvalDataDefaultTypeInternal _EvalData_default_instance_;
class EvalData_OneDataList;
struct EvalData_OneDataListDefaultTypeInternal;
extern EvalData_OneDataListDefaultTypeInternal _EvalData_OneDataList_default_instance_;
class FHEParameter;
struct FHEParameterDefaultTypeInternal;
extern FHEParameterDefaultTypeInternal _FHEParameter_default_instance_;
class OpenFHE_RootMsg;
struct OpenFHE_RootMsgDefaultTypeInternal;
extern OpenFHE_RootMsgDefaultTypeInternal _OpenFHE_RootMsg_default_instance_;
}  // namespace OpenFHE
PROTOBUF_NAMESPACE_OPEN
template<> ::OpenFHE::APISequence* Arena::CreateMaybeMessage<::OpenFHE::APISequence>(Arena*);
template<> ::OpenFHE::APISequence_OneAPI* Arena::CreateMaybeMessage<::OpenFHE::APISequence_OneAPI>(Arena*);
template<> ::OpenFHE::APISequence_OneAPI_AddManyList* Arena::CreateMaybeMessage<::OpenFHE::APISequence_OneAPI_AddManyList>(Arena*);
template<> ::OpenFHE::APISequence_OneAPI_AddTwoList* Arena::CreateMaybeMessage<::OpenFHE::APISequence_OneAPI_AddTwoList>(Arena*);
template<> ::OpenFHE::APISequence_OneAPI_MulManyList* Arena::CreateMaybeMessage<::OpenFHE::APISequence_OneAPI_MulManyList>(Arena*);
template<> ::OpenFHE::APISequence_OneAPI_MulTwoList* Arena::CreateMaybeMessage<::OpenFHE::APISequence_OneAPI_MulTwoList>(Arena*);
template<> ::OpenFHE::APISequence_OneAPI_RotateOneList* Arena::CreateMaybeMessage<::OpenFHE::APISequence_OneAPI_RotateOneList>(Arena*);
template<> ::OpenFHE::APISequence_OneAPI_SubTwoList* Arena::CreateMaybeMessage<::OpenFHE::APISequence_OneAPI_SubTwoList>(Arena*);
template<> ::OpenFHE::EvalData* Arena::CreateMaybeMessage<::OpenFHE::EvalData>(Arena*);
template<> ::OpenFHE::EvalData_OneDataList* Arena::CreateMaybeMessage<::OpenFHE::EvalData_OneDataList>(Arena*);
template<> ::OpenFHE::FHEParameter* Arena::CreateMaybeMessage<::OpenFHE::FHEParameter>(Arena*);
template<> ::OpenFHE::OpenFHE_RootMsg* Arena::CreateMaybeMessage<::OpenFHE::OpenFHE_RootMsg>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace OpenFHE {

enum SecretKeyDist : int {
  GAUSSIAN = 0,
  UNIFORM_TERNARY = 1,
  SPARSE_TERNARY = 2,
  SecretKeyDist_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SecretKeyDist_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SecretKeyDist_IsValid(int value);
constexpr SecretKeyDist SecretKeyDist_MIN = GAUSSIAN;
constexpr SecretKeyDist SecretKeyDist_MAX = SPARSE_TERNARY;
constexpr int SecretKeyDist_ARRAYSIZE = SecretKeyDist_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SecretKeyDist_descriptor();
template<typename T>
inline const std::string& SecretKeyDist_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SecretKeyDist>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SecretKeyDist_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SecretKeyDist_descriptor(), enum_t_value);
}
inline bool SecretKeyDist_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SecretKeyDist* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SecretKeyDist>(
    SecretKeyDist_descriptor(), name, value);
}
enum ScalingTechnique : int {
  FIXEDMANUAL = 0,
  FIXEDAUTO = 1,
  FLEXIBLEAUTO = 2,
  FLEXIBLEAUTOEXT = 3,
  NORESCALE = 4,
  INVALID_RS_TECHNIQUE = 5,
  ScalingTechnique_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ScalingTechnique_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ScalingTechnique_IsValid(int value);
constexpr ScalingTechnique ScalingTechnique_MIN = FIXEDMANUAL;
constexpr ScalingTechnique ScalingTechnique_MAX = INVALID_RS_TECHNIQUE;
constexpr int ScalingTechnique_ARRAYSIZE = ScalingTechnique_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScalingTechnique_descriptor();
template<typename T>
inline const std::string& ScalingTechnique_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScalingTechnique>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScalingTechnique_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ScalingTechnique_descriptor(), enum_t_value);
}
inline bool ScalingTechnique_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ScalingTechnique* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ScalingTechnique>(
    ScalingTechnique_descriptor(), name, value);
}
enum KeySwitchTechnique : int {
  INVALID_KS_TECH = 0,
  BV = 1,
  HYBRID = 2,
  KeySwitchTechnique_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  KeySwitchTechnique_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool KeySwitchTechnique_IsValid(int value);
constexpr KeySwitchTechnique KeySwitchTechnique_MIN = INVALID_KS_TECH;
constexpr KeySwitchTechnique KeySwitchTechnique_MAX = HYBRID;
constexpr int KeySwitchTechnique_ARRAYSIZE = KeySwitchTechnique_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KeySwitchTechnique_descriptor();
template<typename T>
inline const std::string& KeySwitchTechnique_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KeySwitchTechnique>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KeySwitchTechnique_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KeySwitchTechnique_descriptor(), enum_t_value);
}
inline bool KeySwitchTechnique_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KeySwitchTechnique* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KeySwitchTechnique>(
    KeySwitchTechnique_descriptor(), name, value);
}
enum SecurityLevel : int {
  HEStd_128_classic = 0,
  HEStd_192_classic = 1,
  HEStd_256_classic = 2,
  HEStd_NotSet = 3,
  SecurityLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SecurityLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SecurityLevel_IsValid(int value);
constexpr SecurityLevel SecurityLevel_MIN = HEStd_128_classic;
constexpr SecurityLevel SecurityLevel_MAX = HEStd_NotSet;
constexpr int SecurityLevel_ARRAYSIZE = SecurityLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SecurityLevel_descriptor();
template<typename T>
inline const std::string& SecurityLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SecurityLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SecurityLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SecurityLevel_descriptor(), enum_t_value);
}
inline bool SecurityLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SecurityLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SecurityLevel>(
    SecurityLevel_descriptor(), name, value);
}
enum EncryptionTechnique : int {
  STANDARD = 0,
  EXTENDED = 1,
  EncryptionTechnique_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EncryptionTechnique_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EncryptionTechnique_IsValid(int value);
constexpr EncryptionTechnique EncryptionTechnique_MIN = STANDARD;
constexpr EncryptionTechnique EncryptionTechnique_MAX = EXTENDED;
constexpr int EncryptionTechnique_ARRAYSIZE = EncryptionTechnique_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EncryptionTechnique_descriptor();
template<typename T>
inline const std::string& EncryptionTechnique_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EncryptionTechnique>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EncryptionTechnique_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EncryptionTechnique_descriptor(), enum_t_value);
}
inline bool EncryptionTechnique_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EncryptionTechnique* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EncryptionTechnique>(
    EncryptionTechnique_descriptor(), name, value);
}
enum MultiplicationTechnique : int {
  BEHZ = 0,
  HPS = 1,
  HPSPOVERQ = 2,
  HPSPOVERQLEVELED = 3,
  MultiplicationTechnique_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MultiplicationTechnique_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MultiplicationTechnique_IsValid(int value);
constexpr MultiplicationTechnique MultiplicationTechnique_MIN = BEHZ;
constexpr MultiplicationTechnique MultiplicationTechnique_MAX = HPSPOVERQLEVELED;
constexpr int MultiplicationTechnique_ARRAYSIZE = MultiplicationTechnique_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MultiplicationTechnique_descriptor();
template<typename T>
inline const std::string& MultiplicationTechnique_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MultiplicationTechnique>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MultiplicationTechnique_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MultiplicationTechnique_descriptor(), enum_t_value);
}
inline bool MultiplicationTechnique_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MultiplicationTechnique* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MultiplicationTechnique>(
    MultiplicationTechnique_descriptor(), name, value);
}
enum ProxyReEncryptionMode : int {
  NOT_SET = 0,
  INDCPA = 1,
  FIXED_NOISE_HRA = 2,
  NOISE_FLOODING_HRA = 3,
  DIVIDE_AND_ROUND_HRA = 4,
  ProxyReEncryptionMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProxyReEncryptionMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProxyReEncryptionMode_IsValid(int value);
constexpr ProxyReEncryptionMode ProxyReEncryptionMode_MIN = NOT_SET;
constexpr ProxyReEncryptionMode ProxyReEncryptionMode_MAX = DIVIDE_AND_ROUND_HRA;
constexpr int ProxyReEncryptionMode_ARRAYSIZE = ProxyReEncryptionMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProxyReEncryptionMode_descriptor();
template<typename T>
inline const std::string& ProxyReEncryptionMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProxyReEncryptionMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProxyReEncryptionMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProxyReEncryptionMode_descriptor(), enum_t_value);
}
inline bool ProxyReEncryptionMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProxyReEncryptionMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProxyReEncryptionMode>(
    ProxyReEncryptionMode_descriptor(), name, value);
}
enum ExecutionMode : int {
  EXEC_EVALUATION = 0,
  EXEC_NOISE_ESTIMATION = 1,
  ExecutionMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ExecutionMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ExecutionMode_IsValid(int value);
constexpr ExecutionMode ExecutionMode_MIN = EXEC_EVALUATION;
constexpr ExecutionMode ExecutionMode_MAX = EXEC_NOISE_ESTIMATION;
constexpr int ExecutionMode_ARRAYSIZE = ExecutionMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ExecutionMode_descriptor();
template<typename T>
inline const std::string& ExecutionMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExecutionMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExecutionMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ExecutionMode_descriptor(), enum_t_value);
}
inline bool ExecutionMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExecutionMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ExecutionMode>(
    ExecutionMode_descriptor(), name, value);
}
enum DecryptionNoiseMode : int {
  FIXED_NOISE_DECRYPT = 0,
  NOISE_FLOODING_DECRYPT = 1,
  DecryptionNoiseMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DecryptionNoiseMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DecryptionNoiseMode_IsValid(int value);
constexpr DecryptionNoiseMode DecryptionNoiseMode_MIN = FIXED_NOISE_DECRYPT;
constexpr DecryptionNoiseMode DecryptionNoiseMode_MAX = NOISE_FLOODING_DECRYPT;
constexpr int DecryptionNoiseMode_ARRAYSIZE = DecryptionNoiseMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DecryptionNoiseMode_descriptor();
template<typename T>
inline const std::string& DecryptionNoiseMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DecryptionNoiseMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DecryptionNoiseMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DecryptionNoiseMode_descriptor(), enum_t_value);
}
inline bool DecryptionNoiseMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DecryptionNoiseMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DecryptionNoiseMode>(
    DecryptionNoiseMode_descriptor(), name, value);
}
enum MultipartyMode : int {
  INVALID_MULTIPARTY_MODE = 0,
  FIXED_NOISE_MULTIPARTY = 1,
  NOISE_FLOODING_MULTIPARTY = 2,
  MultipartyMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MultipartyMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MultipartyMode_IsValid(int value);
constexpr MultipartyMode MultipartyMode_MIN = INVALID_MULTIPARTY_MODE;
constexpr MultipartyMode MultipartyMode_MAX = NOISE_FLOODING_MULTIPARTY;
constexpr int MultipartyMode_ARRAYSIZE = MultipartyMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MultipartyMode_descriptor();
template<typename T>
inline const std::string& MultipartyMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MultipartyMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MultipartyMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MultipartyMode_descriptor(), enum_t_value);
}
inline bool MultipartyMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MultipartyMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MultipartyMode>(
    MultipartyMode_descriptor(), name, value);
}
// ===================================================================

class OpenFHE_RootMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenFHE.OpenFHE_RootMsg) */ {
 public:
  inline OpenFHE_RootMsg() : OpenFHE_RootMsg(nullptr) {}
  ~OpenFHE_RootMsg() override;
  explicit PROTOBUF_CONSTEXPR OpenFHE_RootMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpenFHE_RootMsg(const OpenFHE_RootMsg& from);
  OpenFHE_RootMsg(OpenFHE_RootMsg&& from) noexcept
    : OpenFHE_RootMsg() {
    *this = ::std::move(from);
  }

  inline OpenFHE_RootMsg& operator=(const OpenFHE_RootMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpenFHE_RootMsg& operator=(OpenFHE_RootMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpenFHE_RootMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpenFHE_RootMsg* internal_default_instance() {
    return reinterpret_cast<const OpenFHE_RootMsg*>(
               &_OpenFHE_RootMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OpenFHE_RootMsg& a, OpenFHE_RootMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(OpenFHE_RootMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpenFHE_RootMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpenFHE_RootMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpenFHE_RootMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpenFHE_RootMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpenFHE_RootMsg& from) {
    OpenFHE_RootMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpenFHE_RootMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenFHE.OpenFHE_RootMsg";
  }
  protected:
  explicit OpenFHE_RootMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamFieldNumber = 1,
    kEvalDataFieldNumber = 2,
    kApiSequenceFieldNumber = 3,
  };
  // .OpenFHE.FHEParameter param = 1;
  bool has_param() const;
  private:
  bool _internal_has_param() const;
  public:
  void clear_param();
  const ::OpenFHE::FHEParameter& param() const;
  PROTOBUF_NODISCARD ::OpenFHE::FHEParameter* release_param();
  ::OpenFHE::FHEParameter* mutable_param();
  void set_allocated_param(::OpenFHE::FHEParameter* param);
  private:
  const ::OpenFHE::FHEParameter& _internal_param() const;
  ::OpenFHE::FHEParameter* _internal_mutable_param();
  public:
  void unsafe_arena_set_allocated_param(
      ::OpenFHE::FHEParameter* param);
  ::OpenFHE::FHEParameter* unsafe_arena_release_param();

  // .OpenFHE.EvalData evalData = 2;
  bool has_evaldata() const;
  private:
  bool _internal_has_evaldata() const;
  public:
  void clear_evaldata();
  const ::OpenFHE::EvalData& evaldata() const;
  PROTOBUF_NODISCARD ::OpenFHE::EvalData* release_evaldata();
  ::OpenFHE::EvalData* mutable_evaldata();
  void set_allocated_evaldata(::OpenFHE::EvalData* evaldata);
  private:
  const ::OpenFHE::EvalData& _internal_evaldata() const;
  ::OpenFHE::EvalData* _internal_mutable_evaldata();
  public:
  void unsafe_arena_set_allocated_evaldata(
      ::OpenFHE::EvalData* evaldata);
  ::OpenFHE::EvalData* unsafe_arena_release_evaldata();

  // .OpenFHE.APISequence apiSequence = 3;
  bool has_apisequence() const;
  private:
  bool _internal_has_apisequence() const;
  public:
  void clear_apisequence();
  const ::OpenFHE::APISequence& apisequence() const;
  PROTOBUF_NODISCARD ::OpenFHE::APISequence* release_apisequence();
  ::OpenFHE::APISequence* mutable_apisequence();
  void set_allocated_apisequence(::OpenFHE::APISequence* apisequence);
  private:
  const ::OpenFHE::APISequence& _internal_apisequence() const;
  ::OpenFHE::APISequence* _internal_mutable_apisequence();
  public:
  void unsafe_arena_set_allocated_apisequence(
      ::OpenFHE::APISequence* apisequence);
  ::OpenFHE::APISequence* unsafe_arena_release_apisequence();

  // @@protoc_insertion_point(class_scope:OpenFHE.OpenFHE_RootMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::OpenFHE::FHEParameter* param_;
    ::OpenFHE::EvalData* evaldata_;
    ::OpenFHE::APISequence* apisequence_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopenfhe_5fbgv_2eproto;
};
// -------------------------------------------------------------------

class FHEParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenFHE.FHEParameter) */ {
 public:
  inline FHEParameter() : FHEParameter(nullptr) {}
  ~FHEParameter() override;
  explicit PROTOBUF_CONSTEXPR FHEParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FHEParameter(const FHEParameter& from);
  FHEParameter(FHEParameter&& from) noexcept
    : FHEParameter() {
    *this = ::std::move(from);
  }

  inline FHEParameter& operator=(const FHEParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline FHEParameter& operator=(FHEParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FHEParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const FHEParameter* internal_default_instance() {
    return reinterpret_cast<const FHEParameter*>(
               &_FHEParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FHEParameter& a, FHEParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(FHEParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FHEParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FHEParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FHEParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FHEParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FHEParameter& from) {
    FHEParameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FHEParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenFHE.FHEParameter";
  }
  protected:
  explicit FHEParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRotateIndexesFieldNumber = 35,
    kPlaintextModulusFieldNumber = 2,
    kMultiplicativeDepthFieldNumber = 1,
    kBatchSizeFieldNumber = 3,
    kDigitSizeFieldNumber = 4,
    kStandardDeviationFieldNumber = 5,
    kSecretKeyDistFieldNumber = 6,
    kMaxRelinSkDegFieldNumber = 7,
    kKsTechFieldNumber = 8,
    kFirstModSizeFieldNumber = 10,
    kScalingModSizeFieldNumber = 11,
    kNumLargeDigitsFieldNumber = 12,
    kSecurityLevelFieldNumber = 13,
    kRingDimFieldNumber = 14,
    kEvalAddCountFieldNumber = 15,
    kKeySwitchCountFieldNumber = 16,
    kEncryptionTechniqueFieldNumber = 17,
    kMultiplicationTechniqueFieldNumber = 18,
    kMultiHopModSizeFieldNumber = 19,
    kPREModeFieldNumber = 20,
    kNoiseEstimateFieldNumber = 24,
    kDesiredPrecisionFieldNumber = 25,
    kStatisticalSecurityFieldNumber = 26,
    kNumAdversarialQueriesFieldNumber = 27,
    kMultipartyModeFieldNumber = 21,
    kPREFieldNumber = 30,
    kMULTIPARTYFieldNumber = 33,
    kFHEFieldNumber = 34,
  };
  // repeated int32 rotateIndexes = 35;
  int rotateindexes_size() const;
  private:
  int _internal_rotateindexes_size() const;
  public:
  void clear_rotateindexes();
  private:
  int32_t _internal_rotateindexes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_rotateindexes() const;
  void _internal_add_rotateindexes(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_rotateindexes();
  public:
  int32_t rotateindexes(int index) const;
  void set_rotateindexes(int index, int32_t value);
  void add_rotateindexes(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      rotateindexes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_rotateindexes();

  // uint64 plaintextModulus = 2;
  void clear_plaintextmodulus();
  uint64_t plaintextmodulus() const;
  void set_plaintextmodulus(uint64_t value);
  private:
  uint64_t _internal_plaintextmodulus() const;
  void _internal_set_plaintextmodulus(uint64_t value);
  public:

  // optional uint32 multiplicativeDepth = 1;
  bool has_multiplicativedepth() const;
  private:
  bool _internal_has_multiplicativedepth() const;
  public:
  void clear_multiplicativedepth();
  uint32_t multiplicativedepth() const;
  void set_multiplicativedepth(uint32_t value);
  private:
  uint32_t _internal_multiplicativedepth() const;
  void _internal_set_multiplicativedepth(uint32_t value);
  public:

  // optional uint32 batchSize = 3;
  bool has_batchsize() const;
  private:
  bool _internal_has_batchsize() const;
  public:
  void clear_batchsize();
  uint32_t batchsize() const;
  void set_batchsize(uint32_t value);
  private:
  uint32_t _internal_batchsize() const;
  void _internal_set_batchsize(uint32_t value);
  public:

  // uint32 digitSize = 4;
  void clear_digitsize();
  uint32_t digitsize() const;
  void set_digitsize(uint32_t value);
  private:
  uint32_t _internal_digitsize() const;
  void _internal_set_digitsize(uint32_t value);
  public:

  // optional float standardDeviation = 5;
  bool has_standarddeviation() const;
  private:
  bool _internal_has_standarddeviation() const;
  public:
  void clear_standarddeviation();
  float standarddeviation() const;
  void set_standarddeviation(float value);
  private:
  float _internal_standarddeviation() const;
  void _internal_set_standarddeviation(float value);
  public:

  // optional .OpenFHE.SecretKeyDist secretKeyDist = 6;
  bool has_secretkeydist() const;
  private:
  bool _internal_has_secretkeydist() const;
  public:
  void clear_secretkeydist();
  ::OpenFHE::SecretKeyDist secretkeydist() const;
  void set_secretkeydist(::OpenFHE::SecretKeyDist value);
  private:
  ::OpenFHE::SecretKeyDist _internal_secretkeydist() const;
  void _internal_set_secretkeydist(::OpenFHE::SecretKeyDist value);
  public:

  // optional uint32 maxRelinSkDeg = 7;
  bool has_maxrelinskdeg() const;
  private:
  bool _internal_has_maxrelinskdeg() const;
  public:
  void clear_maxrelinskdeg();
  uint32_t maxrelinskdeg() const;
  void set_maxrelinskdeg(uint32_t value);
  private:
  uint32_t _internal_maxrelinskdeg() const;
  void _internal_set_maxrelinskdeg(uint32_t value);
  public:

  // optional .OpenFHE.KeySwitchTechnique ksTech = 8;
  bool has_kstech() const;
  private:
  bool _internal_has_kstech() const;
  public:
  void clear_kstech();
  ::OpenFHE::KeySwitchTechnique kstech() const;
  void set_kstech(::OpenFHE::KeySwitchTechnique value);
  private:
  ::OpenFHE::KeySwitchTechnique _internal_kstech() const;
  void _internal_set_kstech(::OpenFHE::KeySwitchTechnique value);
  public:

  // uint32 firstModSize = 10;
  void clear_firstmodsize();
  uint32_t firstmodsize() const;
  void set_firstmodsize(uint32_t value);
  private:
  uint32_t _internal_firstmodsize() const;
  void _internal_set_firstmodsize(uint32_t value);
  public:

  // uint32 scalingModSize = 11;
  void clear_scalingmodsize();
  uint32_t scalingmodsize() const;
  void set_scalingmodsize(uint32_t value);
  private:
  uint32_t _internal_scalingmodsize() const;
  void _internal_set_scalingmodsize(uint32_t value);
  public:

  // uint32 numLargeDigits = 12;
  void clear_numlargedigits();
  uint32_t numlargedigits() const;
  void set_numlargedigits(uint32_t value);
  private:
  uint32_t _internal_numlargedigits() const;
  void _internal_set_numlargedigits(uint32_t value);
  public:

  // .OpenFHE.SecurityLevel securityLevel = 13;
  void clear_securitylevel();
  ::OpenFHE::SecurityLevel securitylevel() const;
  void set_securitylevel(::OpenFHE::SecurityLevel value);
  private:
  ::OpenFHE::SecurityLevel _internal_securitylevel() const;
  void _internal_set_securitylevel(::OpenFHE::SecurityLevel value);
  public:

  // uint32 ringDim = 14;
  void clear_ringdim();
  uint32_t ringdim() const;
  void set_ringdim(uint32_t value);
  private:
  uint32_t _internal_ringdim() const;
  void _internal_set_ringdim(uint32_t value);
  public:

  // optional uint32 evalAddCount = 15;
  bool has_evaladdcount() const;
  private:
  bool _internal_has_evaladdcount() const;
  public:
  void clear_evaladdcount();
  uint32_t evaladdcount() const;
  void set_evaladdcount(uint32_t value);
  private:
  uint32_t _internal_evaladdcount() const;
  void _internal_set_evaladdcount(uint32_t value);
  public:

  // optional uint32 keySwitchCount = 16;
  bool has_keyswitchcount() const;
  private:
  bool _internal_has_keyswitchcount() const;
  public:
  void clear_keyswitchcount();
  uint32_t keyswitchcount() const;
  void set_keyswitchcount(uint32_t value);
  private:
  uint32_t _internal_keyswitchcount() const;
  void _internal_set_keyswitchcount(uint32_t value);
  public:

  // .OpenFHE.EncryptionTechnique encryptionTechnique = 17;
  void clear_encryptiontechnique();
  ::OpenFHE::EncryptionTechnique encryptiontechnique() const;
  void set_encryptiontechnique(::OpenFHE::EncryptionTechnique value);
  private:
  ::OpenFHE::EncryptionTechnique _internal_encryptiontechnique() const;
  void _internal_set_encryptiontechnique(::OpenFHE::EncryptionTechnique value);
  public:

  // optional .OpenFHE.MultiplicationTechnique multiplicationTechnique = 18;
  bool has_multiplicationtechnique() const;
  private:
  bool _internal_has_multiplicationtechnique() const;
  public:
  void clear_multiplicationtechnique();
  ::OpenFHE::MultiplicationTechnique multiplicationtechnique() const;
  void set_multiplicationtechnique(::OpenFHE::MultiplicationTechnique value);
  private:
  ::OpenFHE::MultiplicationTechnique _internal_multiplicationtechnique() const;
  void _internal_set_multiplicationtechnique(::OpenFHE::MultiplicationTechnique value);
  public:

  // uint32 multiHopModSize = 19;
  void clear_multihopmodsize();
  uint32_t multihopmodsize() const;
  void set_multihopmodsize(uint32_t value);
  private:
  uint32_t _internal_multihopmodsize() const;
  void _internal_set_multihopmodsize(uint32_t value);
  public:

  // optional .OpenFHE.ProxyReEncryptionMode PREMode = 20;
  bool has_premode() const;
  private:
  bool _internal_has_premode() const;
  public:
  void clear_premode();
  ::OpenFHE::ProxyReEncryptionMode premode() const;
  void set_premode(::OpenFHE::ProxyReEncryptionMode value);
  private:
  ::OpenFHE::ProxyReEncryptionMode _internal_premode() const;
  void _internal_set_premode(::OpenFHE::ProxyReEncryptionMode value);
  public:

  // double noiseEstimate = 24;
  void clear_noiseestimate();
  double noiseestimate() const;
  void set_noiseestimate(double value);
  private:
  double _internal_noiseestimate() const;
  void _internal_set_noiseestimate(double value);
  public:

  // double desiredPrecision = 25;
  void clear_desiredprecision();
  double desiredprecision() const;
  void set_desiredprecision(double value);
  private:
  double _internal_desiredprecision() const;
  void _internal_set_desiredprecision(double value);
  public:

  // optional double statisticalSecurity = 26;
  bool has_statisticalsecurity() const;
  private:
  bool _internal_has_statisticalsecurity() const;
  public:
  void clear_statisticalsecurity();
  double statisticalsecurity() const;
  void set_statisticalsecurity(double value);
  private:
  double _internal_statisticalsecurity() const;
  void _internal_set_statisticalsecurity(double value);
  public:

  // optional double numAdversarialQueries = 27;
  bool has_numadversarialqueries() const;
  private:
  bool _internal_has_numadversarialqueries() const;
  public:
  void clear_numadversarialqueries();
  double numadversarialqueries() const;
  void set_numadversarialqueries(double value);
  private:
  double _internal_numadversarialqueries() const;
  void _internal_set_numadversarialqueries(double value);
  public:

  // optional .OpenFHE.MultipartyMode multipartyMode = 21;
  bool has_multipartymode() const;
  private:
  bool _internal_has_multipartymode() const;
  public:
  void clear_multipartymode();
  ::OpenFHE::MultipartyMode multipartymode() const;
  void set_multipartymode(::OpenFHE::MultipartyMode value);
  private:
  ::OpenFHE::MultipartyMode _internal_multipartymode() const;
  void _internal_set_multipartymode(::OpenFHE::MultipartyMode value);
  public:

  // bool PRE = 30;
  void clear_pre();
  bool pre() const;
  void set_pre(bool value);
  private:
  bool _internal_pre() const;
  void _internal_set_pre(bool value);
  public:

  // bool MULTIPARTY = 33;
  void clear_multiparty();
  bool multiparty() const;
  void set_multiparty(bool value);
  private:
  bool _internal_multiparty() const;
  void _internal_set_multiparty(bool value);
  public:

  // bool FHE = 34;
  void clear_fhe();
  bool fhe() const;
  void set_fhe(bool value);
  private:
  bool _internal_fhe() const;
  void _internal_set_fhe(bool value);
  public:

  // @@protoc_insertion_point(class_scope:OpenFHE.FHEParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > rotateindexes_;
    mutable std::atomic<int> _rotateindexes_cached_byte_size_;
    uint64_t plaintextmodulus_;
    uint32_t multiplicativedepth_;
    uint32_t batchsize_;
    uint32_t digitsize_;
    float standarddeviation_;
    int secretkeydist_;
    uint32_t maxrelinskdeg_;
    int kstech_;
    uint32_t firstmodsize_;
    uint32_t scalingmodsize_;
    uint32_t numlargedigits_;
    int securitylevel_;
    uint32_t ringdim_;
    uint32_t evaladdcount_;
    uint32_t keyswitchcount_;
    int encryptiontechnique_;
    int multiplicationtechnique_;
    uint32_t multihopmodsize_;
    int premode_;
    double noiseestimate_;
    double desiredprecision_;
    double statisticalsecurity_;
    double numadversarialqueries_;
    int multipartymode_;
    bool pre_;
    bool multiparty_;
    bool fhe_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopenfhe_5fbgv_2eproto;
};
// -------------------------------------------------------------------

class EvalData_OneDataList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenFHE.EvalData.OneDataList) */ {
 public:
  inline EvalData_OneDataList() : EvalData_OneDataList(nullptr) {}
  ~EvalData_OneDataList() override;
  explicit PROTOBUF_CONSTEXPR EvalData_OneDataList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EvalData_OneDataList(const EvalData_OneDataList& from);
  EvalData_OneDataList(EvalData_OneDataList&& from) noexcept
    : EvalData_OneDataList() {
    *this = ::std::move(from);
  }

  inline EvalData_OneDataList& operator=(const EvalData_OneDataList& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvalData_OneDataList& operator=(EvalData_OneDataList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EvalData_OneDataList& default_instance() {
    return *internal_default_instance();
  }
  static inline const EvalData_OneDataList* internal_default_instance() {
    return reinterpret_cast<const EvalData_OneDataList*>(
               &_EvalData_OneDataList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(EvalData_OneDataList& a, EvalData_OneDataList& b) {
    a.Swap(&b);
  }
  inline void Swap(EvalData_OneDataList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvalData_OneDataList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EvalData_OneDataList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EvalData_OneDataList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EvalData_OneDataList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EvalData_OneDataList& from) {
    EvalData_OneDataList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EvalData_OneDataList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenFHE.EvalData.OneDataList";
  }
  protected:
  explicit EvalData_OneDataList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataListFieldNumber = 1,
  };
  // repeated int32 dataList = 1;
  int datalist_size() const;
  private:
  int _internal_datalist_size() const;
  public:
  void clear_datalist();
  private:
  int32_t _internal_datalist(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_datalist() const;
  void _internal_add_datalist(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_datalist();
  public:
  int32_t datalist(int index) const;
  void set_datalist(int index, int32_t value);
  void add_datalist(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      datalist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_datalist();

  // @@protoc_insertion_point(class_scope:OpenFHE.EvalData.OneDataList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > datalist_;
    mutable std::atomic<int> _datalist_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopenfhe_5fbgv_2eproto;
};
// -------------------------------------------------------------------

class EvalData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenFHE.EvalData) */ {
 public:
  inline EvalData() : EvalData(nullptr) {}
  ~EvalData() override;
  explicit PROTOBUF_CONSTEXPR EvalData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EvalData(const EvalData& from);
  EvalData(EvalData&& from) noexcept
    : EvalData() {
    *this = ::std::move(from);
  }

  inline EvalData& operator=(const EvalData& from) {
    CopyFrom(from);
    return *this;
  }
  inline EvalData& operator=(EvalData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EvalData& default_instance() {
    return *internal_default_instance();
  }
  static inline const EvalData* internal_default_instance() {
    return reinterpret_cast<const EvalData*>(
               &_EvalData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(EvalData& a, EvalData& b) {
    a.Swap(&b);
  }
  inline void Swap(EvalData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EvalData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EvalData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EvalData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EvalData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EvalData& from) {
    EvalData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EvalData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenFHE.EvalData";
  }
  protected:
  explicit EvalData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EvalData_OneDataList OneDataList;

  // accessors -------------------------------------------------------

  enum : int {
    kAllDataListsFieldNumber = 2,
  };
  // repeated .OpenFHE.EvalData.OneDataList allDataLists = 2;
  int alldatalists_size() const;
  private:
  int _internal_alldatalists_size() const;
  public:
  void clear_alldatalists();
  ::OpenFHE::EvalData_OneDataList* mutable_alldatalists(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenFHE::EvalData_OneDataList >*
      mutable_alldatalists();
  private:
  const ::OpenFHE::EvalData_OneDataList& _internal_alldatalists(int index) const;
  ::OpenFHE::EvalData_OneDataList* _internal_add_alldatalists();
  public:
  const ::OpenFHE::EvalData_OneDataList& alldatalists(int index) const;
  ::OpenFHE::EvalData_OneDataList* add_alldatalists();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenFHE::EvalData_OneDataList >&
      alldatalists() const;

  // @@protoc_insertion_point(class_scope:OpenFHE.EvalData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenFHE::EvalData_OneDataList > alldatalists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopenfhe_5fbgv_2eproto;
};
// -------------------------------------------------------------------

class APISequence_OneAPI_AddTwoList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenFHE.APISequence.OneAPI.AddTwoList) */ {
 public:
  inline APISequence_OneAPI_AddTwoList() : APISequence_OneAPI_AddTwoList(nullptr) {}
  ~APISequence_OneAPI_AddTwoList() override;
  explicit PROTOBUF_CONSTEXPR APISequence_OneAPI_AddTwoList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APISequence_OneAPI_AddTwoList(const APISequence_OneAPI_AddTwoList& from);
  APISequence_OneAPI_AddTwoList(APISequence_OneAPI_AddTwoList&& from) noexcept
    : APISequence_OneAPI_AddTwoList() {
    *this = ::std::move(from);
  }

  inline APISequence_OneAPI_AddTwoList& operator=(const APISequence_OneAPI_AddTwoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline APISequence_OneAPI_AddTwoList& operator=(APISequence_OneAPI_AddTwoList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APISequence_OneAPI_AddTwoList& default_instance() {
    return *internal_default_instance();
  }
  static inline const APISequence_OneAPI_AddTwoList* internal_default_instance() {
    return reinterpret_cast<const APISequence_OneAPI_AddTwoList*>(
               &_APISequence_OneAPI_AddTwoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(APISequence_OneAPI_AddTwoList& a, APISequence_OneAPI_AddTwoList& b) {
    a.Swap(&b);
  }
  inline void Swap(APISequence_OneAPI_AddTwoList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APISequence_OneAPI_AddTwoList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APISequence_OneAPI_AddTwoList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APISequence_OneAPI_AddTwoList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APISequence_OneAPI_AddTwoList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APISequence_OneAPI_AddTwoList& from) {
    APISequence_OneAPI_AddTwoList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APISequence_OneAPI_AddTwoList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenFHE.APISequence.OneAPI.AddTwoList";
  }
  protected:
  explicit APISequence_OneAPI_AddTwoList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrc1FieldNumber = 1,
    kSrc2FieldNumber = 2,
  };
  // uint32 src1 = 1;
  void clear_src1();
  uint32_t src1() const;
  void set_src1(uint32_t value);
  private:
  uint32_t _internal_src1() const;
  void _internal_set_src1(uint32_t value);
  public:

  // uint32 src2 = 2;
  void clear_src2();
  uint32_t src2() const;
  void set_src2(uint32_t value);
  private:
  uint32_t _internal_src2() const;
  void _internal_set_src2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OpenFHE.APISequence.OneAPI.AddTwoList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t src1_;
    uint32_t src2_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopenfhe_5fbgv_2eproto;
};
// -------------------------------------------------------------------

class APISequence_OneAPI_AddManyList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenFHE.APISequence.OneAPI.AddManyList) */ {
 public:
  inline APISequence_OneAPI_AddManyList() : APISequence_OneAPI_AddManyList(nullptr) {}
  ~APISequence_OneAPI_AddManyList() override;
  explicit PROTOBUF_CONSTEXPR APISequence_OneAPI_AddManyList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APISequence_OneAPI_AddManyList(const APISequence_OneAPI_AddManyList& from);
  APISequence_OneAPI_AddManyList(APISequence_OneAPI_AddManyList&& from) noexcept
    : APISequence_OneAPI_AddManyList() {
    *this = ::std::move(from);
  }

  inline APISequence_OneAPI_AddManyList& operator=(const APISequence_OneAPI_AddManyList& from) {
    CopyFrom(from);
    return *this;
  }
  inline APISequence_OneAPI_AddManyList& operator=(APISequence_OneAPI_AddManyList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APISequence_OneAPI_AddManyList& default_instance() {
    return *internal_default_instance();
  }
  static inline const APISequence_OneAPI_AddManyList* internal_default_instance() {
    return reinterpret_cast<const APISequence_OneAPI_AddManyList*>(
               &_APISequence_OneAPI_AddManyList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(APISequence_OneAPI_AddManyList& a, APISequence_OneAPI_AddManyList& b) {
    a.Swap(&b);
  }
  inline void Swap(APISequence_OneAPI_AddManyList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APISequence_OneAPI_AddManyList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APISequence_OneAPI_AddManyList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APISequence_OneAPI_AddManyList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APISequence_OneAPI_AddManyList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APISequence_OneAPI_AddManyList& from) {
    APISequence_OneAPI_AddManyList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APISequence_OneAPI_AddManyList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenFHE.APISequence.OneAPI.AddManyList";
  }
  protected:
  explicit APISequence_OneAPI_AddManyList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcsFieldNumber = 1,
  };
  // repeated uint32 srcs = 1;
  int srcs_size() const;
  private:
  int _internal_srcs_size() const;
  public:
  void clear_srcs();
  private:
  uint32_t _internal_srcs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_srcs() const;
  void _internal_add_srcs(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_srcs();
  public:
  uint32_t srcs(int index) const;
  void set_srcs(int index, uint32_t value);
  void add_srcs(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      srcs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_srcs();

  // @@protoc_insertion_point(class_scope:OpenFHE.APISequence.OneAPI.AddManyList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > srcs_;
    mutable std::atomic<int> _srcs_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopenfhe_5fbgv_2eproto;
};
// -------------------------------------------------------------------

class APISequence_OneAPI_SubTwoList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenFHE.APISequence.OneAPI.SubTwoList) */ {
 public:
  inline APISequence_OneAPI_SubTwoList() : APISequence_OneAPI_SubTwoList(nullptr) {}
  ~APISequence_OneAPI_SubTwoList() override;
  explicit PROTOBUF_CONSTEXPR APISequence_OneAPI_SubTwoList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APISequence_OneAPI_SubTwoList(const APISequence_OneAPI_SubTwoList& from);
  APISequence_OneAPI_SubTwoList(APISequence_OneAPI_SubTwoList&& from) noexcept
    : APISequence_OneAPI_SubTwoList() {
    *this = ::std::move(from);
  }

  inline APISequence_OneAPI_SubTwoList& operator=(const APISequence_OneAPI_SubTwoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline APISequence_OneAPI_SubTwoList& operator=(APISequence_OneAPI_SubTwoList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APISequence_OneAPI_SubTwoList& default_instance() {
    return *internal_default_instance();
  }
  static inline const APISequence_OneAPI_SubTwoList* internal_default_instance() {
    return reinterpret_cast<const APISequence_OneAPI_SubTwoList*>(
               &_APISequence_OneAPI_SubTwoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(APISequence_OneAPI_SubTwoList& a, APISequence_OneAPI_SubTwoList& b) {
    a.Swap(&b);
  }
  inline void Swap(APISequence_OneAPI_SubTwoList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APISequence_OneAPI_SubTwoList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APISequence_OneAPI_SubTwoList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APISequence_OneAPI_SubTwoList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APISequence_OneAPI_SubTwoList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APISequence_OneAPI_SubTwoList& from) {
    APISequence_OneAPI_SubTwoList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APISequence_OneAPI_SubTwoList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenFHE.APISequence.OneAPI.SubTwoList";
  }
  protected:
  explicit APISequence_OneAPI_SubTwoList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrc1FieldNumber = 1,
    kSrc2FieldNumber = 2,
  };
  // uint32 src1 = 1;
  void clear_src1();
  uint32_t src1() const;
  void set_src1(uint32_t value);
  private:
  uint32_t _internal_src1() const;
  void _internal_set_src1(uint32_t value);
  public:

  // uint32 src2 = 2;
  void clear_src2();
  uint32_t src2() const;
  void set_src2(uint32_t value);
  private:
  uint32_t _internal_src2() const;
  void _internal_set_src2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OpenFHE.APISequence.OneAPI.SubTwoList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t src1_;
    uint32_t src2_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopenfhe_5fbgv_2eproto;
};
// -------------------------------------------------------------------

class APISequence_OneAPI_MulTwoList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenFHE.APISequence.OneAPI.MulTwoList) */ {
 public:
  inline APISequence_OneAPI_MulTwoList() : APISequence_OneAPI_MulTwoList(nullptr) {}
  ~APISequence_OneAPI_MulTwoList() override;
  explicit PROTOBUF_CONSTEXPR APISequence_OneAPI_MulTwoList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APISequence_OneAPI_MulTwoList(const APISequence_OneAPI_MulTwoList& from);
  APISequence_OneAPI_MulTwoList(APISequence_OneAPI_MulTwoList&& from) noexcept
    : APISequence_OneAPI_MulTwoList() {
    *this = ::std::move(from);
  }

  inline APISequence_OneAPI_MulTwoList& operator=(const APISequence_OneAPI_MulTwoList& from) {
    CopyFrom(from);
    return *this;
  }
  inline APISequence_OneAPI_MulTwoList& operator=(APISequence_OneAPI_MulTwoList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APISequence_OneAPI_MulTwoList& default_instance() {
    return *internal_default_instance();
  }
  static inline const APISequence_OneAPI_MulTwoList* internal_default_instance() {
    return reinterpret_cast<const APISequence_OneAPI_MulTwoList*>(
               &_APISequence_OneAPI_MulTwoList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(APISequence_OneAPI_MulTwoList& a, APISequence_OneAPI_MulTwoList& b) {
    a.Swap(&b);
  }
  inline void Swap(APISequence_OneAPI_MulTwoList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APISequence_OneAPI_MulTwoList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APISequence_OneAPI_MulTwoList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APISequence_OneAPI_MulTwoList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APISequence_OneAPI_MulTwoList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APISequence_OneAPI_MulTwoList& from) {
    APISequence_OneAPI_MulTwoList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APISequence_OneAPI_MulTwoList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenFHE.APISequence.OneAPI.MulTwoList";
  }
  protected:
  explicit APISequence_OneAPI_MulTwoList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrc1FieldNumber = 1,
    kSrc2FieldNumber = 2,
  };
  // uint32 src1 = 1;
  void clear_src1();
  uint32_t src1() const;
  void set_src1(uint32_t value);
  private:
  uint32_t _internal_src1() const;
  void _internal_set_src1(uint32_t value);
  public:

  // uint32 src2 = 2;
  void clear_src2();
  uint32_t src2() const;
  void set_src2(uint32_t value);
  private:
  uint32_t _internal_src2() const;
  void _internal_set_src2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OpenFHE.APISequence.OneAPI.MulTwoList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t src1_;
    uint32_t src2_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopenfhe_5fbgv_2eproto;
};
// -------------------------------------------------------------------

class APISequence_OneAPI_MulManyList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenFHE.APISequence.OneAPI.MulManyList) */ {
 public:
  inline APISequence_OneAPI_MulManyList() : APISequence_OneAPI_MulManyList(nullptr) {}
  ~APISequence_OneAPI_MulManyList() override;
  explicit PROTOBUF_CONSTEXPR APISequence_OneAPI_MulManyList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APISequence_OneAPI_MulManyList(const APISequence_OneAPI_MulManyList& from);
  APISequence_OneAPI_MulManyList(APISequence_OneAPI_MulManyList&& from) noexcept
    : APISequence_OneAPI_MulManyList() {
    *this = ::std::move(from);
  }

  inline APISequence_OneAPI_MulManyList& operator=(const APISequence_OneAPI_MulManyList& from) {
    CopyFrom(from);
    return *this;
  }
  inline APISequence_OneAPI_MulManyList& operator=(APISequence_OneAPI_MulManyList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APISequence_OneAPI_MulManyList& default_instance() {
    return *internal_default_instance();
  }
  static inline const APISequence_OneAPI_MulManyList* internal_default_instance() {
    return reinterpret_cast<const APISequence_OneAPI_MulManyList*>(
               &_APISequence_OneAPI_MulManyList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(APISequence_OneAPI_MulManyList& a, APISequence_OneAPI_MulManyList& b) {
    a.Swap(&b);
  }
  inline void Swap(APISequence_OneAPI_MulManyList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APISequence_OneAPI_MulManyList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APISequence_OneAPI_MulManyList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APISequence_OneAPI_MulManyList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APISequence_OneAPI_MulManyList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APISequence_OneAPI_MulManyList& from) {
    APISequence_OneAPI_MulManyList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APISequence_OneAPI_MulManyList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenFHE.APISequence.OneAPI.MulManyList";
  }
  protected:
  explicit APISequence_OneAPI_MulManyList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcsFieldNumber = 1,
  };
  // repeated uint32 srcs = 1;
  int srcs_size() const;
  private:
  int _internal_srcs_size() const;
  public:
  void clear_srcs();
  private:
  uint32_t _internal_srcs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_srcs() const;
  void _internal_add_srcs(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_srcs();
  public:
  uint32_t srcs(int index) const;
  void set_srcs(int index, uint32_t value);
  void add_srcs(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      srcs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_srcs();

  // @@protoc_insertion_point(class_scope:OpenFHE.APISequence.OneAPI.MulManyList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > srcs_;
    mutable std::atomic<int> _srcs_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopenfhe_5fbgv_2eproto;
};
// -------------------------------------------------------------------

class APISequence_OneAPI_RotateOneList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenFHE.APISequence.OneAPI.RotateOneList) */ {
 public:
  inline APISequence_OneAPI_RotateOneList() : APISequence_OneAPI_RotateOneList(nullptr) {}
  ~APISequence_OneAPI_RotateOneList() override;
  explicit PROTOBUF_CONSTEXPR APISequence_OneAPI_RotateOneList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APISequence_OneAPI_RotateOneList(const APISequence_OneAPI_RotateOneList& from);
  APISequence_OneAPI_RotateOneList(APISequence_OneAPI_RotateOneList&& from) noexcept
    : APISequence_OneAPI_RotateOneList() {
    *this = ::std::move(from);
  }

  inline APISequence_OneAPI_RotateOneList& operator=(const APISequence_OneAPI_RotateOneList& from) {
    CopyFrom(from);
    return *this;
  }
  inline APISequence_OneAPI_RotateOneList& operator=(APISequence_OneAPI_RotateOneList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APISequence_OneAPI_RotateOneList& default_instance() {
    return *internal_default_instance();
  }
  static inline const APISequence_OneAPI_RotateOneList* internal_default_instance() {
    return reinterpret_cast<const APISequence_OneAPI_RotateOneList*>(
               &_APISequence_OneAPI_RotateOneList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(APISequence_OneAPI_RotateOneList& a, APISequence_OneAPI_RotateOneList& b) {
    a.Swap(&b);
  }
  inline void Swap(APISequence_OneAPI_RotateOneList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APISequence_OneAPI_RotateOneList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APISequence_OneAPI_RotateOneList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APISequence_OneAPI_RotateOneList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APISequence_OneAPI_RotateOneList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APISequence_OneAPI_RotateOneList& from) {
    APISequence_OneAPI_RotateOneList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APISequence_OneAPI_RotateOneList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenFHE.APISequence.OneAPI.RotateOneList";
  }
  protected:
  explicit APISequence_OneAPI_RotateOneList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kIndexFieldNumber = 2,
  };
  // uint32 src = 1;
  void clear_src();
  uint32_t src() const;
  void set_src(uint32_t value);
  private:
  uint32_t _internal_src() const;
  void _internal_set_src(uint32_t value);
  public:

  // int32 index = 2;
  void clear_index();
  int32_t index() const;
  void set_index(int32_t value);
  private:
  int32_t _internal_index() const;
  void _internal_set_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:OpenFHE.APISequence.OneAPI.RotateOneList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t src_;
    int32_t index_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopenfhe_5fbgv_2eproto;
};
// -------------------------------------------------------------------

class APISequence_OneAPI final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenFHE.APISequence.OneAPI) */ {
 public:
  inline APISequence_OneAPI() : APISequence_OneAPI(nullptr) {}
  ~APISequence_OneAPI() override;
  explicit PROTOBUF_CONSTEXPR APISequence_OneAPI(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APISequence_OneAPI(const APISequence_OneAPI& from);
  APISequence_OneAPI(APISequence_OneAPI&& from) noexcept
    : APISequence_OneAPI() {
    *this = ::std::move(from);
  }

  inline APISequence_OneAPI& operator=(const APISequence_OneAPI& from) {
    CopyFrom(from);
    return *this;
  }
  inline APISequence_OneAPI& operator=(APISequence_OneAPI&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APISequence_OneAPI& default_instance() {
    return *internal_default_instance();
  }
  enum ApiCase {
    kAddTwoList = 1,
    kAddManyList = 2,
    kSubTwoList = 3,
    kMulTwoList = 4,
    kMulManyList = 5,
    kRotateOneList = 6,
    API_NOT_SET = 0,
  };

  static inline const APISequence_OneAPI* internal_default_instance() {
    return reinterpret_cast<const APISequence_OneAPI*>(
               &_APISequence_OneAPI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(APISequence_OneAPI& a, APISequence_OneAPI& b) {
    a.Swap(&b);
  }
  inline void Swap(APISequence_OneAPI* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APISequence_OneAPI* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APISequence_OneAPI* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APISequence_OneAPI>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APISequence_OneAPI& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APISequence_OneAPI& from) {
    APISequence_OneAPI::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APISequence_OneAPI* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenFHE.APISequence.OneAPI";
  }
  protected:
  explicit APISequence_OneAPI(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef APISequence_OneAPI_AddTwoList AddTwoList;
  typedef APISequence_OneAPI_AddManyList AddManyList;
  typedef APISequence_OneAPI_SubTwoList SubTwoList;
  typedef APISequence_OneAPI_MulTwoList MulTwoList;
  typedef APISequence_OneAPI_MulManyList MulManyList;
  typedef APISequence_OneAPI_RotateOneList RotateOneList;

  // accessors -------------------------------------------------------

  enum : int {
    kDstFieldNumber = 7,
    kAddTwoListFieldNumber = 1,
    kAddManyListFieldNumber = 2,
    kSubTwoListFieldNumber = 3,
    kMulTwoListFieldNumber = 4,
    kMulManyListFieldNumber = 5,
    kRotateOneListFieldNumber = 6,
  };
  // uint32 dst = 7;
  void clear_dst();
  uint32_t dst() const;
  void set_dst(uint32_t value);
  private:
  uint32_t _internal_dst() const;
  void _internal_set_dst(uint32_t value);
  public:

  // .OpenFHE.APISequence.OneAPI.AddTwoList addTwoList = 1;
  bool has_addtwolist() const;
  private:
  bool _internal_has_addtwolist() const;
  public:
  void clear_addtwolist();
  const ::OpenFHE::APISequence_OneAPI_AddTwoList& addtwolist() const;
  PROTOBUF_NODISCARD ::OpenFHE::APISequence_OneAPI_AddTwoList* release_addtwolist();
  ::OpenFHE::APISequence_OneAPI_AddTwoList* mutable_addtwolist();
  void set_allocated_addtwolist(::OpenFHE::APISequence_OneAPI_AddTwoList* addtwolist);
  private:
  const ::OpenFHE::APISequence_OneAPI_AddTwoList& _internal_addtwolist() const;
  ::OpenFHE::APISequence_OneAPI_AddTwoList* _internal_mutable_addtwolist();
  public:
  void unsafe_arena_set_allocated_addtwolist(
      ::OpenFHE::APISequence_OneAPI_AddTwoList* addtwolist);
  ::OpenFHE::APISequence_OneAPI_AddTwoList* unsafe_arena_release_addtwolist();

  // .OpenFHE.APISequence.OneAPI.AddManyList addManyList = 2;
  bool has_addmanylist() const;
  private:
  bool _internal_has_addmanylist() const;
  public:
  void clear_addmanylist();
  const ::OpenFHE::APISequence_OneAPI_AddManyList& addmanylist() const;
  PROTOBUF_NODISCARD ::OpenFHE::APISequence_OneAPI_AddManyList* release_addmanylist();
  ::OpenFHE::APISequence_OneAPI_AddManyList* mutable_addmanylist();
  void set_allocated_addmanylist(::OpenFHE::APISequence_OneAPI_AddManyList* addmanylist);
  private:
  const ::OpenFHE::APISequence_OneAPI_AddManyList& _internal_addmanylist() const;
  ::OpenFHE::APISequence_OneAPI_AddManyList* _internal_mutable_addmanylist();
  public:
  void unsafe_arena_set_allocated_addmanylist(
      ::OpenFHE::APISequence_OneAPI_AddManyList* addmanylist);
  ::OpenFHE::APISequence_OneAPI_AddManyList* unsafe_arena_release_addmanylist();

  // .OpenFHE.APISequence.OneAPI.SubTwoList subTwoList = 3;
  bool has_subtwolist() const;
  private:
  bool _internal_has_subtwolist() const;
  public:
  void clear_subtwolist();
  const ::OpenFHE::APISequence_OneAPI_SubTwoList& subtwolist() const;
  PROTOBUF_NODISCARD ::OpenFHE::APISequence_OneAPI_SubTwoList* release_subtwolist();
  ::OpenFHE::APISequence_OneAPI_SubTwoList* mutable_subtwolist();
  void set_allocated_subtwolist(::OpenFHE::APISequence_OneAPI_SubTwoList* subtwolist);
  private:
  const ::OpenFHE::APISequence_OneAPI_SubTwoList& _internal_subtwolist() const;
  ::OpenFHE::APISequence_OneAPI_SubTwoList* _internal_mutable_subtwolist();
  public:
  void unsafe_arena_set_allocated_subtwolist(
      ::OpenFHE::APISequence_OneAPI_SubTwoList* subtwolist);
  ::OpenFHE::APISequence_OneAPI_SubTwoList* unsafe_arena_release_subtwolist();

  // .OpenFHE.APISequence.OneAPI.MulTwoList mulTwoList = 4;
  bool has_multwolist() const;
  private:
  bool _internal_has_multwolist() const;
  public:
  void clear_multwolist();
  const ::OpenFHE::APISequence_OneAPI_MulTwoList& multwolist() const;
  PROTOBUF_NODISCARD ::OpenFHE::APISequence_OneAPI_MulTwoList* release_multwolist();
  ::OpenFHE::APISequence_OneAPI_MulTwoList* mutable_multwolist();
  void set_allocated_multwolist(::OpenFHE::APISequence_OneAPI_MulTwoList* multwolist);
  private:
  const ::OpenFHE::APISequence_OneAPI_MulTwoList& _internal_multwolist() const;
  ::OpenFHE::APISequence_OneAPI_MulTwoList* _internal_mutable_multwolist();
  public:
  void unsafe_arena_set_allocated_multwolist(
      ::OpenFHE::APISequence_OneAPI_MulTwoList* multwolist);
  ::OpenFHE::APISequence_OneAPI_MulTwoList* unsafe_arena_release_multwolist();

  // .OpenFHE.APISequence.OneAPI.MulManyList mulManyList = 5;
  bool has_mulmanylist() const;
  private:
  bool _internal_has_mulmanylist() const;
  public:
  void clear_mulmanylist();
  const ::OpenFHE::APISequence_OneAPI_MulManyList& mulmanylist() const;
  PROTOBUF_NODISCARD ::OpenFHE::APISequence_OneAPI_MulManyList* release_mulmanylist();
  ::OpenFHE::APISequence_OneAPI_MulManyList* mutable_mulmanylist();
  void set_allocated_mulmanylist(::OpenFHE::APISequence_OneAPI_MulManyList* mulmanylist);
  private:
  const ::OpenFHE::APISequence_OneAPI_MulManyList& _internal_mulmanylist() const;
  ::OpenFHE::APISequence_OneAPI_MulManyList* _internal_mutable_mulmanylist();
  public:
  void unsafe_arena_set_allocated_mulmanylist(
      ::OpenFHE::APISequence_OneAPI_MulManyList* mulmanylist);
  ::OpenFHE::APISequence_OneAPI_MulManyList* unsafe_arena_release_mulmanylist();

  // .OpenFHE.APISequence.OneAPI.RotateOneList rotateOneList = 6;
  bool has_rotateonelist() const;
  private:
  bool _internal_has_rotateonelist() const;
  public:
  void clear_rotateonelist();
  const ::OpenFHE::APISequence_OneAPI_RotateOneList& rotateonelist() const;
  PROTOBUF_NODISCARD ::OpenFHE::APISequence_OneAPI_RotateOneList* release_rotateonelist();
  ::OpenFHE::APISequence_OneAPI_RotateOneList* mutable_rotateonelist();
  void set_allocated_rotateonelist(::OpenFHE::APISequence_OneAPI_RotateOneList* rotateonelist);
  private:
  const ::OpenFHE::APISequence_OneAPI_RotateOneList& _internal_rotateonelist() const;
  ::OpenFHE::APISequence_OneAPI_RotateOneList* _internal_mutable_rotateonelist();
  public:
  void unsafe_arena_set_allocated_rotateonelist(
      ::OpenFHE::APISequence_OneAPI_RotateOneList* rotateonelist);
  ::OpenFHE::APISequence_OneAPI_RotateOneList* unsafe_arena_release_rotateonelist();

  void clear_api();
  ApiCase api_case() const;
  // @@protoc_insertion_point(class_scope:OpenFHE.APISequence.OneAPI)
 private:
  class _Internal;
  void set_has_addtwolist();
  void set_has_addmanylist();
  void set_has_subtwolist();
  void set_has_multwolist();
  void set_has_mulmanylist();
  void set_has_rotateonelist();

  inline bool has_api() const;
  inline void clear_has_api();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t dst_;
    union ApiUnion {
      constexpr ApiUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::OpenFHE::APISequence_OneAPI_AddTwoList* addtwolist_;
      ::OpenFHE::APISequence_OneAPI_AddManyList* addmanylist_;
      ::OpenFHE::APISequence_OneAPI_SubTwoList* subtwolist_;
      ::OpenFHE::APISequence_OneAPI_MulTwoList* multwolist_;
      ::OpenFHE::APISequence_OneAPI_MulManyList* mulmanylist_;
      ::OpenFHE::APISequence_OneAPI_RotateOneList* rotateonelist_;
    } api_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopenfhe_5fbgv_2eproto;
};
// -------------------------------------------------------------------

class APISequence final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpenFHE.APISequence) */ {
 public:
  inline APISequence() : APISequence(nullptr) {}
  ~APISequence() override;
  explicit PROTOBUF_CONSTEXPR APISequence(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APISequence(const APISequence& from);
  APISequence(APISequence&& from) noexcept
    : APISequence() {
    *this = ::std::move(from);
  }

  inline APISequence& operator=(const APISequence& from) {
    CopyFrom(from);
    return *this;
  }
  inline APISequence& operator=(APISequence&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APISequence& default_instance() {
    return *internal_default_instance();
  }
  static inline const APISequence* internal_default_instance() {
    return reinterpret_cast<const APISequence*>(
               &_APISequence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(APISequence& a, APISequence& b) {
    a.Swap(&b);
  }
  inline void Swap(APISequence* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APISequence* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APISequence* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APISequence>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APISequence& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const APISequence& from) {
    APISequence::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APISequence* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpenFHE.APISequence";
  }
  protected:
  explicit APISequence(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef APISequence_OneAPI OneAPI;

  // accessors -------------------------------------------------------

  enum : int {
    kApiListFieldNumber = 1,
  };
  // repeated .OpenFHE.APISequence.OneAPI apiList = 1;
  int apilist_size() const;
  private:
  int _internal_apilist_size() const;
  public:
  void clear_apilist();
  ::OpenFHE::APISequence_OneAPI* mutable_apilist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenFHE::APISequence_OneAPI >*
      mutable_apilist();
  private:
  const ::OpenFHE::APISequence_OneAPI& _internal_apilist(int index) const;
  ::OpenFHE::APISequence_OneAPI* _internal_add_apilist();
  public:
  const ::OpenFHE::APISequence_OneAPI& apilist(int index) const;
  ::OpenFHE::APISequence_OneAPI* add_apilist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenFHE::APISequence_OneAPI >&
      apilist() const;

  // @@protoc_insertion_point(class_scope:OpenFHE.APISequence)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenFHE::APISequence_OneAPI > apilist_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_proto_2fopenfhe_5fbgv_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OpenFHE_RootMsg

// .OpenFHE.FHEParameter param = 1;
inline bool OpenFHE_RootMsg::_internal_has_param() const {
  return this != internal_default_instance() && _impl_.param_ != nullptr;
}
inline bool OpenFHE_RootMsg::has_param() const {
  return _internal_has_param();
}
inline void OpenFHE_RootMsg::clear_param() {
  if (GetArenaForAllocation() == nullptr && _impl_.param_ != nullptr) {
    delete _impl_.param_;
  }
  _impl_.param_ = nullptr;
}
inline const ::OpenFHE::FHEParameter& OpenFHE_RootMsg::_internal_param() const {
  const ::OpenFHE::FHEParameter* p = _impl_.param_;
  return p != nullptr ? *p : reinterpret_cast<const ::OpenFHE::FHEParameter&>(
      ::OpenFHE::_FHEParameter_default_instance_);
}
inline const ::OpenFHE::FHEParameter& OpenFHE_RootMsg::param() const {
  // @@protoc_insertion_point(field_get:OpenFHE.OpenFHE_RootMsg.param)
  return _internal_param();
}
inline void OpenFHE_RootMsg::unsafe_arena_set_allocated_param(
    ::OpenFHE::FHEParameter* param) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.param_);
  }
  _impl_.param_ = param;
  if (param) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OpenFHE.OpenFHE_RootMsg.param)
}
inline ::OpenFHE::FHEParameter* OpenFHE_RootMsg::release_param() {
  
  ::OpenFHE::FHEParameter* temp = _impl_.param_;
  _impl_.param_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OpenFHE::FHEParameter* OpenFHE_RootMsg::unsafe_arena_release_param() {
  // @@protoc_insertion_point(field_release:OpenFHE.OpenFHE_RootMsg.param)
  
  ::OpenFHE::FHEParameter* temp = _impl_.param_;
  _impl_.param_ = nullptr;
  return temp;
}
inline ::OpenFHE::FHEParameter* OpenFHE_RootMsg::_internal_mutable_param() {
  
  if (_impl_.param_ == nullptr) {
    auto* p = CreateMaybeMessage<::OpenFHE::FHEParameter>(GetArenaForAllocation());
    _impl_.param_ = p;
  }
  return _impl_.param_;
}
inline ::OpenFHE::FHEParameter* OpenFHE_RootMsg::mutable_param() {
  ::OpenFHE::FHEParameter* _msg = _internal_mutable_param();
  // @@protoc_insertion_point(field_mutable:OpenFHE.OpenFHE_RootMsg.param)
  return _msg;
}
inline void OpenFHE_RootMsg::set_allocated_param(::OpenFHE::FHEParameter* param) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.param_;
  }
  if (param) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(param);
    if (message_arena != submessage_arena) {
      param = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, param, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.param_ = param;
  // @@protoc_insertion_point(field_set_allocated:OpenFHE.OpenFHE_RootMsg.param)
}

// .OpenFHE.EvalData evalData = 2;
inline bool OpenFHE_RootMsg::_internal_has_evaldata() const {
  return this != internal_default_instance() && _impl_.evaldata_ != nullptr;
}
inline bool OpenFHE_RootMsg::has_evaldata() const {
  return _internal_has_evaldata();
}
inline void OpenFHE_RootMsg::clear_evaldata() {
  if (GetArenaForAllocation() == nullptr && _impl_.evaldata_ != nullptr) {
    delete _impl_.evaldata_;
  }
  _impl_.evaldata_ = nullptr;
}
inline const ::OpenFHE::EvalData& OpenFHE_RootMsg::_internal_evaldata() const {
  const ::OpenFHE::EvalData* p = _impl_.evaldata_;
  return p != nullptr ? *p : reinterpret_cast<const ::OpenFHE::EvalData&>(
      ::OpenFHE::_EvalData_default_instance_);
}
inline const ::OpenFHE::EvalData& OpenFHE_RootMsg::evaldata() const {
  // @@protoc_insertion_point(field_get:OpenFHE.OpenFHE_RootMsg.evalData)
  return _internal_evaldata();
}
inline void OpenFHE_RootMsg::unsafe_arena_set_allocated_evaldata(
    ::OpenFHE::EvalData* evaldata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.evaldata_);
  }
  _impl_.evaldata_ = evaldata;
  if (evaldata) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OpenFHE.OpenFHE_RootMsg.evalData)
}
inline ::OpenFHE::EvalData* OpenFHE_RootMsg::release_evaldata() {
  
  ::OpenFHE::EvalData* temp = _impl_.evaldata_;
  _impl_.evaldata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OpenFHE::EvalData* OpenFHE_RootMsg::unsafe_arena_release_evaldata() {
  // @@protoc_insertion_point(field_release:OpenFHE.OpenFHE_RootMsg.evalData)
  
  ::OpenFHE::EvalData* temp = _impl_.evaldata_;
  _impl_.evaldata_ = nullptr;
  return temp;
}
inline ::OpenFHE::EvalData* OpenFHE_RootMsg::_internal_mutable_evaldata() {
  
  if (_impl_.evaldata_ == nullptr) {
    auto* p = CreateMaybeMessage<::OpenFHE::EvalData>(GetArenaForAllocation());
    _impl_.evaldata_ = p;
  }
  return _impl_.evaldata_;
}
inline ::OpenFHE::EvalData* OpenFHE_RootMsg::mutable_evaldata() {
  ::OpenFHE::EvalData* _msg = _internal_mutable_evaldata();
  // @@protoc_insertion_point(field_mutable:OpenFHE.OpenFHE_RootMsg.evalData)
  return _msg;
}
inline void OpenFHE_RootMsg::set_allocated_evaldata(::OpenFHE::EvalData* evaldata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.evaldata_;
  }
  if (evaldata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(evaldata);
    if (message_arena != submessage_arena) {
      evaldata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, evaldata, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.evaldata_ = evaldata;
  // @@protoc_insertion_point(field_set_allocated:OpenFHE.OpenFHE_RootMsg.evalData)
}

// .OpenFHE.APISequence apiSequence = 3;
inline bool OpenFHE_RootMsg::_internal_has_apisequence() const {
  return this != internal_default_instance() && _impl_.apisequence_ != nullptr;
}
inline bool OpenFHE_RootMsg::has_apisequence() const {
  return _internal_has_apisequence();
}
inline void OpenFHE_RootMsg::clear_apisequence() {
  if (GetArenaForAllocation() == nullptr && _impl_.apisequence_ != nullptr) {
    delete _impl_.apisequence_;
  }
  _impl_.apisequence_ = nullptr;
}
inline const ::OpenFHE::APISequence& OpenFHE_RootMsg::_internal_apisequence() const {
  const ::OpenFHE::APISequence* p = _impl_.apisequence_;
  return p != nullptr ? *p : reinterpret_cast<const ::OpenFHE::APISequence&>(
      ::OpenFHE::_APISequence_default_instance_);
}
inline const ::OpenFHE::APISequence& OpenFHE_RootMsg::apisequence() const {
  // @@protoc_insertion_point(field_get:OpenFHE.OpenFHE_RootMsg.apiSequence)
  return _internal_apisequence();
}
inline void OpenFHE_RootMsg::unsafe_arena_set_allocated_apisequence(
    ::OpenFHE::APISequence* apisequence) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.apisequence_);
  }
  _impl_.apisequence_ = apisequence;
  if (apisequence) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OpenFHE.OpenFHE_RootMsg.apiSequence)
}
inline ::OpenFHE::APISequence* OpenFHE_RootMsg::release_apisequence() {
  
  ::OpenFHE::APISequence* temp = _impl_.apisequence_;
  _impl_.apisequence_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OpenFHE::APISequence* OpenFHE_RootMsg::unsafe_arena_release_apisequence() {
  // @@protoc_insertion_point(field_release:OpenFHE.OpenFHE_RootMsg.apiSequence)
  
  ::OpenFHE::APISequence* temp = _impl_.apisequence_;
  _impl_.apisequence_ = nullptr;
  return temp;
}
inline ::OpenFHE::APISequence* OpenFHE_RootMsg::_internal_mutable_apisequence() {
  
  if (_impl_.apisequence_ == nullptr) {
    auto* p = CreateMaybeMessage<::OpenFHE::APISequence>(GetArenaForAllocation());
    _impl_.apisequence_ = p;
  }
  return _impl_.apisequence_;
}
inline ::OpenFHE::APISequence* OpenFHE_RootMsg::mutable_apisequence() {
  ::OpenFHE::APISequence* _msg = _internal_mutable_apisequence();
  // @@protoc_insertion_point(field_mutable:OpenFHE.OpenFHE_RootMsg.apiSequence)
  return _msg;
}
inline void OpenFHE_RootMsg::set_allocated_apisequence(::OpenFHE::APISequence* apisequence) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.apisequence_;
  }
  if (apisequence) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(apisequence);
    if (message_arena != submessage_arena) {
      apisequence = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, apisequence, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.apisequence_ = apisequence;
  // @@protoc_insertion_point(field_set_allocated:OpenFHE.OpenFHE_RootMsg.apiSequence)
}

// -------------------------------------------------------------------

// FHEParameter

// optional uint32 multiplicativeDepth = 1;
inline bool FHEParameter::_internal_has_multiplicativedepth() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FHEParameter::has_multiplicativedepth() const {
  return _internal_has_multiplicativedepth();
}
inline void FHEParameter::clear_multiplicativedepth() {
  _impl_.multiplicativedepth_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t FHEParameter::_internal_multiplicativedepth() const {
  return _impl_.multiplicativedepth_;
}
inline uint32_t FHEParameter::multiplicativedepth() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.multiplicativeDepth)
  return _internal_multiplicativedepth();
}
inline void FHEParameter::_internal_set_multiplicativedepth(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.multiplicativedepth_ = value;
}
inline void FHEParameter::set_multiplicativedepth(uint32_t value) {
  _internal_set_multiplicativedepth(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.multiplicativeDepth)
}

// uint64 plaintextModulus = 2;
inline void FHEParameter::clear_plaintextmodulus() {
  _impl_.plaintextmodulus_ = uint64_t{0u};
}
inline uint64_t FHEParameter::_internal_plaintextmodulus() const {
  return _impl_.plaintextmodulus_;
}
inline uint64_t FHEParameter::plaintextmodulus() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.plaintextModulus)
  return _internal_plaintextmodulus();
}
inline void FHEParameter::_internal_set_plaintextmodulus(uint64_t value) {
  
  _impl_.plaintextmodulus_ = value;
}
inline void FHEParameter::set_plaintextmodulus(uint64_t value) {
  _internal_set_plaintextmodulus(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.plaintextModulus)
}

// optional uint32 batchSize = 3;
inline bool FHEParameter::_internal_has_batchsize() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FHEParameter::has_batchsize() const {
  return _internal_has_batchsize();
}
inline void FHEParameter::clear_batchsize() {
  _impl_.batchsize_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t FHEParameter::_internal_batchsize() const {
  return _impl_.batchsize_;
}
inline uint32_t FHEParameter::batchsize() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.batchSize)
  return _internal_batchsize();
}
inline void FHEParameter::_internal_set_batchsize(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.batchsize_ = value;
}
inline void FHEParameter::set_batchsize(uint32_t value) {
  _internal_set_batchsize(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.batchSize)
}

// uint32 digitSize = 4;
inline void FHEParameter::clear_digitsize() {
  _impl_.digitsize_ = 0u;
}
inline uint32_t FHEParameter::_internal_digitsize() const {
  return _impl_.digitsize_;
}
inline uint32_t FHEParameter::digitsize() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.digitSize)
  return _internal_digitsize();
}
inline void FHEParameter::_internal_set_digitsize(uint32_t value) {
  
  _impl_.digitsize_ = value;
}
inline void FHEParameter::set_digitsize(uint32_t value) {
  _internal_set_digitsize(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.digitSize)
}

// optional float standardDeviation = 5;
inline bool FHEParameter::_internal_has_standarddeviation() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool FHEParameter::has_standarddeviation() const {
  return _internal_has_standarddeviation();
}
inline void FHEParameter::clear_standarddeviation() {
  _impl_.standarddeviation_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float FHEParameter::_internal_standarddeviation() const {
  return _impl_.standarddeviation_;
}
inline float FHEParameter::standarddeviation() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.standardDeviation)
  return _internal_standarddeviation();
}
inline void FHEParameter::_internal_set_standarddeviation(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.standarddeviation_ = value;
}
inline void FHEParameter::set_standarddeviation(float value) {
  _internal_set_standarddeviation(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.standardDeviation)
}

// optional .OpenFHE.SecretKeyDist secretKeyDist = 6;
inline bool FHEParameter::_internal_has_secretkeydist() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool FHEParameter::has_secretkeydist() const {
  return _internal_has_secretkeydist();
}
inline void FHEParameter::clear_secretkeydist() {
  _impl_.secretkeydist_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline ::OpenFHE::SecretKeyDist FHEParameter::_internal_secretkeydist() const {
  return static_cast< ::OpenFHE::SecretKeyDist >(_impl_.secretkeydist_);
}
inline ::OpenFHE::SecretKeyDist FHEParameter::secretkeydist() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.secretKeyDist)
  return _internal_secretkeydist();
}
inline void FHEParameter::_internal_set_secretkeydist(::OpenFHE::SecretKeyDist value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.secretkeydist_ = value;
}
inline void FHEParameter::set_secretkeydist(::OpenFHE::SecretKeyDist value) {
  _internal_set_secretkeydist(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.secretKeyDist)
}

// optional uint32 maxRelinSkDeg = 7;
inline bool FHEParameter::_internal_has_maxrelinskdeg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool FHEParameter::has_maxrelinskdeg() const {
  return _internal_has_maxrelinskdeg();
}
inline void FHEParameter::clear_maxrelinskdeg() {
  _impl_.maxrelinskdeg_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t FHEParameter::_internal_maxrelinskdeg() const {
  return _impl_.maxrelinskdeg_;
}
inline uint32_t FHEParameter::maxrelinskdeg() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.maxRelinSkDeg)
  return _internal_maxrelinskdeg();
}
inline void FHEParameter::_internal_set_maxrelinskdeg(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.maxrelinskdeg_ = value;
}
inline void FHEParameter::set_maxrelinskdeg(uint32_t value) {
  _internal_set_maxrelinskdeg(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.maxRelinSkDeg)
}

// optional .OpenFHE.KeySwitchTechnique ksTech = 8;
inline bool FHEParameter::_internal_has_kstech() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool FHEParameter::has_kstech() const {
  return _internal_has_kstech();
}
inline void FHEParameter::clear_kstech() {
  _impl_.kstech_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline ::OpenFHE::KeySwitchTechnique FHEParameter::_internal_kstech() const {
  return static_cast< ::OpenFHE::KeySwitchTechnique >(_impl_.kstech_);
}
inline ::OpenFHE::KeySwitchTechnique FHEParameter::kstech() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.ksTech)
  return _internal_kstech();
}
inline void FHEParameter::_internal_set_kstech(::OpenFHE::KeySwitchTechnique value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.kstech_ = value;
}
inline void FHEParameter::set_kstech(::OpenFHE::KeySwitchTechnique value) {
  _internal_set_kstech(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.ksTech)
}

// uint32 firstModSize = 10;
inline void FHEParameter::clear_firstmodsize() {
  _impl_.firstmodsize_ = 0u;
}
inline uint32_t FHEParameter::_internal_firstmodsize() const {
  return _impl_.firstmodsize_;
}
inline uint32_t FHEParameter::firstmodsize() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.firstModSize)
  return _internal_firstmodsize();
}
inline void FHEParameter::_internal_set_firstmodsize(uint32_t value) {
  
  _impl_.firstmodsize_ = value;
}
inline void FHEParameter::set_firstmodsize(uint32_t value) {
  _internal_set_firstmodsize(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.firstModSize)
}

// uint32 scalingModSize = 11;
inline void FHEParameter::clear_scalingmodsize() {
  _impl_.scalingmodsize_ = 0u;
}
inline uint32_t FHEParameter::_internal_scalingmodsize() const {
  return _impl_.scalingmodsize_;
}
inline uint32_t FHEParameter::scalingmodsize() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.scalingModSize)
  return _internal_scalingmodsize();
}
inline void FHEParameter::_internal_set_scalingmodsize(uint32_t value) {
  
  _impl_.scalingmodsize_ = value;
}
inline void FHEParameter::set_scalingmodsize(uint32_t value) {
  _internal_set_scalingmodsize(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.scalingModSize)
}

// uint32 numLargeDigits = 12;
inline void FHEParameter::clear_numlargedigits() {
  _impl_.numlargedigits_ = 0u;
}
inline uint32_t FHEParameter::_internal_numlargedigits() const {
  return _impl_.numlargedigits_;
}
inline uint32_t FHEParameter::numlargedigits() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.numLargeDigits)
  return _internal_numlargedigits();
}
inline void FHEParameter::_internal_set_numlargedigits(uint32_t value) {
  
  _impl_.numlargedigits_ = value;
}
inline void FHEParameter::set_numlargedigits(uint32_t value) {
  _internal_set_numlargedigits(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.numLargeDigits)
}

// .OpenFHE.SecurityLevel securityLevel = 13;
inline void FHEParameter::clear_securitylevel() {
  _impl_.securitylevel_ = 0;
}
inline ::OpenFHE::SecurityLevel FHEParameter::_internal_securitylevel() const {
  return static_cast< ::OpenFHE::SecurityLevel >(_impl_.securitylevel_);
}
inline ::OpenFHE::SecurityLevel FHEParameter::securitylevel() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.securityLevel)
  return _internal_securitylevel();
}
inline void FHEParameter::_internal_set_securitylevel(::OpenFHE::SecurityLevel value) {
  
  _impl_.securitylevel_ = value;
}
inline void FHEParameter::set_securitylevel(::OpenFHE::SecurityLevel value) {
  _internal_set_securitylevel(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.securityLevel)
}

// uint32 ringDim = 14;
inline void FHEParameter::clear_ringdim() {
  _impl_.ringdim_ = 0u;
}
inline uint32_t FHEParameter::_internal_ringdim() const {
  return _impl_.ringdim_;
}
inline uint32_t FHEParameter::ringdim() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.ringDim)
  return _internal_ringdim();
}
inline void FHEParameter::_internal_set_ringdim(uint32_t value) {
  
  _impl_.ringdim_ = value;
}
inline void FHEParameter::set_ringdim(uint32_t value) {
  _internal_set_ringdim(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.ringDim)
}

// optional uint32 evalAddCount = 15;
inline bool FHEParameter::_internal_has_evaladdcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool FHEParameter::has_evaladdcount() const {
  return _internal_has_evaladdcount();
}
inline void FHEParameter::clear_evaladdcount() {
  _impl_.evaladdcount_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline uint32_t FHEParameter::_internal_evaladdcount() const {
  return _impl_.evaladdcount_;
}
inline uint32_t FHEParameter::evaladdcount() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.evalAddCount)
  return _internal_evaladdcount();
}
inline void FHEParameter::_internal_set_evaladdcount(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.evaladdcount_ = value;
}
inline void FHEParameter::set_evaladdcount(uint32_t value) {
  _internal_set_evaladdcount(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.evalAddCount)
}

// optional uint32 keySwitchCount = 16;
inline bool FHEParameter::_internal_has_keyswitchcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool FHEParameter::has_keyswitchcount() const {
  return _internal_has_keyswitchcount();
}
inline void FHEParameter::clear_keyswitchcount() {
  _impl_.keyswitchcount_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline uint32_t FHEParameter::_internal_keyswitchcount() const {
  return _impl_.keyswitchcount_;
}
inline uint32_t FHEParameter::keyswitchcount() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.keySwitchCount)
  return _internal_keyswitchcount();
}
inline void FHEParameter::_internal_set_keyswitchcount(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.keyswitchcount_ = value;
}
inline void FHEParameter::set_keyswitchcount(uint32_t value) {
  _internal_set_keyswitchcount(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.keySwitchCount)
}

// .OpenFHE.EncryptionTechnique encryptionTechnique = 17;
inline void FHEParameter::clear_encryptiontechnique() {
  _impl_.encryptiontechnique_ = 0;
}
inline ::OpenFHE::EncryptionTechnique FHEParameter::_internal_encryptiontechnique() const {
  return static_cast< ::OpenFHE::EncryptionTechnique >(_impl_.encryptiontechnique_);
}
inline ::OpenFHE::EncryptionTechnique FHEParameter::encryptiontechnique() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.encryptionTechnique)
  return _internal_encryptiontechnique();
}
inline void FHEParameter::_internal_set_encryptiontechnique(::OpenFHE::EncryptionTechnique value) {
  
  _impl_.encryptiontechnique_ = value;
}
inline void FHEParameter::set_encryptiontechnique(::OpenFHE::EncryptionTechnique value) {
  _internal_set_encryptiontechnique(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.encryptionTechnique)
}

// optional .OpenFHE.MultiplicationTechnique multiplicationTechnique = 18;
inline bool FHEParameter::_internal_has_multiplicationtechnique() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool FHEParameter::has_multiplicationtechnique() const {
  return _internal_has_multiplicationtechnique();
}
inline void FHEParameter::clear_multiplicationtechnique() {
  _impl_.multiplicationtechnique_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline ::OpenFHE::MultiplicationTechnique FHEParameter::_internal_multiplicationtechnique() const {
  return static_cast< ::OpenFHE::MultiplicationTechnique >(_impl_.multiplicationtechnique_);
}
inline ::OpenFHE::MultiplicationTechnique FHEParameter::multiplicationtechnique() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.multiplicationTechnique)
  return _internal_multiplicationtechnique();
}
inline void FHEParameter::_internal_set_multiplicationtechnique(::OpenFHE::MultiplicationTechnique value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.multiplicationtechnique_ = value;
}
inline void FHEParameter::set_multiplicationtechnique(::OpenFHE::MultiplicationTechnique value) {
  _internal_set_multiplicationtechnique(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.multiplicationTechnique)
}

// uint32 multiHopModSize = 19;
inline void FHEParameter::clear_multihopmodsize() {
  _impl_.multihopmodsize_ = 0u;
}
inline uint32_t FHEParameter::_internal_multihopmodsize() const {
  return _impl_.multihopmodsize_;
}
inline uint32_t FHEParameter::multihopmodsize() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.multiHopModSize)
  return _internal_multihopmodsize();
}
inline void FHEParameter::_internal_set_multihopmodsize(uint32_t value) {
  
  _impl_.multihopmodsize_ = value;
}
inline void FHEParameter::set_multihopmodsize(uint32_t value) {
  _internal_set_multihopmodsize(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.multiHopModSize)
}

// optional .OpenFHE.ProxyReEncryptionMode PREMode = 20;
inline bool FHEParameter::_internal_has_premode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool FHEParameter::has_premode() const {
  return _internal_has_premode();
}
inline void FHEParameter::clear_premode() {
  _impl_.premode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline ::OpenFHE::ProxyReEncryptionMode FHEParameter::_internal_premode() const {
  return static_cast< ::OpenFHE::ProxyReEncryptionMode >(_impl_.premode_);
}
inline ::OpenFHE::ProxyReEncryptionMode FHEParameter::premode() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.PREMode)
  return _internal_premode();
}
inline void FHEParameter::_internal_set_premode(::OpenFHE::ProxyReEncryptionMode value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.premode_ = value;
}
inline void FHEParameter::set_premode(::OpenFHE::ProxyReEncryptionMode value) {
  _internal_set_premode(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.PREMode)
}

// double noiseEstimate = 24;
inline void FHEParameter::clear_noiseestimate() {
  _impl_.noiseestimate_ = 0;
}
inline double FHEParameter::_internal_noiseestimate() const {
  return _impl_.noiseestimate_;
}
inline double FHEParameter::noiseestimate() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.noiseEstimate)
  return _internal_noiseestimate();
}
inline void FHEParameter::_internal_set_noiseestimate(double value) {
  
  _impl_.noiseestimate_ = value;
}
inline void FHEParameter::set_noiseestimate(double value) {
  _internal_set_noiseestimate(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.noiseEstimate)
}

// double desiredPrecision = 25;
inline void FHEParameter::clear_desiredprecision() {
  _impl_.desiredprecision_ = 0;
}
inline double FHEParameter::_internal_desiredprecision() const {
  return _impl_.desiredprecision_;
}
inline double FHEParameter::desiredprecision() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.desiredPrecision)
  return _internal_desiredprecision();
}
inline void FHEParameter::_internal_set_desiredprecision(double value) {
  
  _impl_.desiredprecision_ = value;
}
inline void FHEParameter::set_desiredprecision(double value) {
  _internal_set_desiredprecision(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.desiredPrecision)
}

// optional double statisticalSecurity = 26;
inline bool FHEParameter::_internal_has_statisticalsecurity() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool FHEParameter::has_statisticalsecurity() const {
  return _internal_has_statisticalsecurity();
}
inline void FHEParameter::clear_statisticalsecurity() {
  _impl_.statisticalsecurity_ = 0;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline double FHEParameter::_internal_statisticalsecurity() const {
  return _impl_.statisticalsecurity_;
}
inline double FHEParameter::statisticalsecurity() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.statisticalSecurity)
  return _internal_statisticalsecurity();
}
inline void FHEParameter::_internal_set_statisticalsecurity(double value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.statisticalsecurity_ = value;
}
inline void FHEParameter::set_statisticalsecurity(double value) {
  _internal_set_statisticalsecurity(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.statisticalSecurity)
}

// optional double numAdversarialQueries = 27;
inline bool FHEParameter::_internal_has_numadversarialqueries() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool FHEParameter::has_numadversarialqueries() const {
  return _internal_has_numadversarialqueries();
}
inline void FHEParameter::clear_numadversarialqueries() {
  _impl_.numadversarialqueries_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline double FHEParameter::_internal_numadversarialqueries() const {
  return _impl_.numadversarialqueries_;
}
inline double FHEParameter::numadversarialqueries() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.numAdversarialQueries)
  return _internal_numadversarialqueries();
}
inline void FHEParameter::_internal_set_numadversarialqueries(double value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.numadversarialqueries_ = value;
}
inline void FHEParameter::set_numadversarialqueries(double value) {
  _internal_set_numadversarialqueries(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.numAdversarialQueries)
}

// optional .OpenFHE.MultipartyMode multipartyMode = 21;
inline bool FHEParameter::_internal_has_multipartymode() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool FHEParameter::has_multipartymode() const {
  return _internal_has_multipartymode();
}
inline void FHEParameter::clear_multipartymode() {
  _impl_.multipartymode_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline ::OpenFHE::MultipartyMode FHEParameter::_internal_multipartymode() const {
  return static_cast< ::OpenFHE::MultipartyMode >(_impl_.multipartymode_);
}
inline ::OpenFHE::MultipartyMode FHEParameter::multipartymode() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.multipartyMode)
  return _internal_multipartymode();
}
inline void FHEParameter::_internal_set_multipartymode(::OpenFHE::MultipartyMode value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.multipartymode_ = value;
}
inline void FHEParameter::set_multipartymode(::OpenFHE::MultipartyMode value) {
  _internal_set_multipartymode(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.multipartyMode)
}

// bool PRE = 30;
inline void FHEParameter::clear_pre() {
  _impl_.pre_ = false;
}
inline bool FHEParameter::_internal_pre() const {
  return _impl_.pre_;
}
inline bool FHEParameter::pre() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.PRE)
  return _internal_pre();
}
inline void FHEParameter::_internal_set_pre(bool value) {
  
  _impl_.pre_ = value;
}
inline void FHEParameter::set_pre(bool value) {
  _internal_set_pre(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.PRE)
}

// bool MULTIPARTY = 33;
inline void FHEParameter::clear_multiparty() {
  _impl_.multiparty_ = false;
}
inline bool FHEParameter::_internal_multiparty() const {
  return _impl_.multiparty_;
}
inline bool FHEParameter::multiparty() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.MULTIPARTY)
  return _internal_multiparty();
}
inline void FHEParameter::_internal_set_multiparty(bool value) {
  
  _impl_.multiparty_ = value;
}
inline void FHEParameter::set_multiparty(bool value) {
  _internal_set_multiparty(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.MULTIPARTY)
}

// bool FHE = 34;
inline void FHEParameter::clear_fhe() {
  _impl_.fhe_ = false;
}
inline bool FHEParameter::_internal_fhe() const {
  return _impl_.fhe_;
}
inline bool FHEParameter::fhe() const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.FHE)
  return _internal_fhe();
}
inline void FHEParameter::_internal_set_fhe(bool value) {
  
  _impl_.fhe_ = value;
}
inline void FHEParameter::set_fhe(bool value) {
  _internal_set_fhe(value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.FHE)
}

// repeated int32 rotateIndexes = 35;
inline int FHEParameter::_internal_rotateindexes_size() const {
  return _impl_.rotateindexes_.size();
}
inline int FHEParameter::rotateindexes_size() const {
  return _internal_rotateindexes_size();
}
inline void FHEParameter::clear_rotateindexes() {
  _impl_.rotateindexes_.Clear();
}
inline int32_t FHEParameter::_internal_rotateindexes(int index) const {
  return _impl_.rotateindexes_.Get(index);
}
inline int32_t FHEParameter::rotateindexes(int index) const {
  // @@protoc_insertion_point(field_get:OpenFHE.FHEParameter.rotateIndexes)
  return _internal_rotateindexes(index);
}
inline void FHEParameter::set_rotateindexes(int index, int32_t value) {
  _impl_.rotateindexes_.Set(index, value);
  // @@protoc_insertion_point(field_set:OpenFHE.FHEParameter.rotateIndexes)
}
inline void FHEParameter::_internal_add_rotateindexes(int32_t value) {
  _impl_.rotateindexes_.Add(value);
}
inline void FHEParameter::add_rotateindexes(int32_t value) {
  _internal_add_rotateindexes(value);
  // @@protoc_insertion_point(field_add:OpenFHE.FHEParameter.rotateIndexes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
FHEParameter::_internal_rotateindexes() const {
  return _impl_.rotateindexes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
FHEParameter::rotateindexes() const {
  // @@protoc_insertion_point(field_list:OpenFHE.FHEParameter.rotateIndexes)
  return _internal_rotateindexes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
FHEParameter::_internal_mutable_rotateindexes() {
  return &_impl_.rotateindexes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
FHEParameter::mutable_rotateindexes() {
  // @@protoc_insertion_point(field_mutable_list:OpenFHE.FHEParameter.rotateIndexes)
  return _internal_mutable_rotateindexes();
}

// -------------------------------------------------------------------

// EvalData_OneDataList

// repeated int32 dataList = 1;
inline int EvalData_OneDataList::_internal_datalist_size() const {
  return _impl_.datalist_.size();
}
inline int EvalData_OneDataList::datalist_size() const {
  return _internal_datalist_size();
}
inline void EvalData_OneDataList::clear_datalist() {
  _impl_.datalist_.Clear();
}
inline int32_t EvalData_OneDataList::_internal_datalist(int index) const {
  return _impl_.datalist_.Get(index);
}
inline int32_t EvalData_OneDataList::datalist(int index) const {
  // @@protoc_insertion_point(field_get:OpenFHE.EvalData.OneDataList.dataList)
  return _internal_datalist(index);
}
inline void EvalData_OneDataList::set_datalist(int index, int32_t value) {
  _impl_.datalist_.Set(index, value);
  // @@protoc_insertion_point(field_set:OpenFHE.EvalData.OneDataList.dataList)
}
inline void EvalData_OneDataList::_internal_add_datalist(int32_t value) {
  _impl_.datalist_.Add(value);
}
inline void EvalData_OneDataList::add_datalist(int32_t value) {
  _internal_add_datalist(value);
  // @@protoc_insertion_point(field_add:OpenFHE.EvalData.OneDataList.dataList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
EvalData_OneDataList::_internal_datalist() const {
  return _impl_.datalist_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
EvalData_OneDataList::datalist() const {
  // @@protoc_insertion_point(field_list:OpenFHE.EvalData.OneDataList.dataList)
  return _internal_datalist();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
EvalData_OneDataList::_internal_mutable_datalist() {
  return &_impl_.datalist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
EvalData_OneDataList::mutable_datalist() {
  // @@protoc_insertion_point(field_mutable_list:OpenFHE.EvalData.OneDataList.dataList)
  return _internal_mutable_datalist();
}

// -------------------------------------------------------------------

// EvalData

// repeated .OpenFHE.EvalData.OneDataList allDataLists = 2;
inline int EvalData::_internal_alldatalists_size() const {
  return _impl_.alldatalists_.size();
}
inline int EvalData::alldatalists_size() const {
  return _internal_alldatalists_size();
}
inline void EvalData::clear_alldatalists() {
  _impl_.alldatalists_.Clear();
}
inline ::OpenFHE::EvalData_OneDataList* EvalData::mutable_alldatalists(int index) {
  // @@protoc_insertion_point(field_mutable:OpenFHE.EvalData.allDataLists)
  return _impl_.alldatalists_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenFHE::EvalData_OneDataList >*
EvalData::mutable_alldatalists() {
  // @@protoc_insertion_point(field_mutable_list:OpenFHE.EvalData.allDataLists)
  return &_impl_.alldatalists_;
}
inline const ::OpenFHE::EvalData_OneDataList& EvalData::_internal_alldatalists(int index) const {
  return _impl_.alldatalists_.Get(index);
}
inline const ::OpenFHE::EvalData_OneDataList& EvalData::alldatalists(int index) const {
  // @@protoc_insertion_point(field_get:OpenFHE.EvalData.allDataLists)
  return _internal_alldatalists(index);
}
inline ::OpenFHE::EvalData_OneDataList* EvalData::_internal_add_alldatalists() {
  return _impl_.alldatalists_.Add();
}
inline ::OpenFHE::EvalData_OneDataList* EvalData::add_alldatalists() {
  ::OpenFHE::EvalData_OneDataList* _add = _internal_add_alldatalists();
  // @@protoc_insertion_point(field_add:OpenFHE.EvalData.allDataLists)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenFHE::EvalData_OneDataList >&
EvalData::alldatalists() const {
  // @@protoc_insertion_point(field_list:OpenFHE.EvalData.allDataLists)
  return _impl_.alldatalists_;
}

// -------------------------------------------------------------------

// APISequence_OneAPI_AddTwoList

// uint32 src1 = 1;
inline void APISequence_OneAPI_AddTwoList::clear_src1() {
  _impl_.src1_ = 0u;
}
inline uint32_t APISequence_OneAPI_AddTwoList::_internal_src1() const {
  return _impl_.src1_;
}
inline uint32_t APISequence_OneAPI_AddTwoList::src1() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.AddTwoList.src1)
  return _internal_src1();
}
inline void APISequence_OneAPI_AddTwoList::_internal_set_src1(uint32_t value) {
  
  _impl_.src1_ = value;
}
inline void APISequence_OneAPI_AddTwoList::set_src1(uint32_t value) {
  _internal_set_src1(value);
  // @@protoc_insertion_point(field_set:OpenFHE.APISequence.OneAPI.AddTwoList.src1)
}

// uint32 src2 = 2;
inline void APISequence_OneAPI_AddTwoList::clear_src2() {
  _impl_.src2_ = 0u;
}
inline uint32_t APISequence_OneAPI_AddTwoList::_internal_src2() const {
  return _impl_.src2_;
}
inline uint32_t APISequence_OneAPI_AddTwoList::src2() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.AddTwoList.src2)
  return _internal_src2();
}
inline void APISequence_OneAPI_AddTwoList::_internal_set_src2(uint32_t value) {
  
  _impl_.src2_ = value;
}
inline void APISequence_OneAPI_AddTwoList::set_src2(uint32_t value) {
  _internal_set_src2(value);
  // @@protoc_insertion_point(field_set:OpenFHE.APISequence.OneAPI.AddTwoList.src2)
}

// -------------------------------------------------------------------

// APISequence_OneAPI_AddManyList

// repeated uint32 srcs = 1;
inline int APISequence_OneAPI_AddManyList::_internal_srcs_size() const {
  return _impl_.srcs_.size();
}
inline int APISequence_OneAPI_AddManyList::srcs_size() const {
  return _internal_srcs_size();
}
inline void APISequence_OneAPI_AddManyList::clear_srcs() {
  _impl_.srcs_.Clear();
}
inline uint32_t APISequence_OneAPI_AddManyList::_internal_srcs(int index) const {
  return _impl_.srcs_.Get(index);
}
inline uint32_t APISequence_OneAPI_AddManyList::srcs(int index) const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.AddManyList.srcs)
  return _internal_srcs(index);
}
inline void APISequence_OneAPI_AddManyList::set_srcs(int index, uint32_t value) {
  _impl_.srcs_.Set(index, value);
  // @@protoc_insertion_point(field_set:OpenFHE.APISequence.OneAPI.AddManyList.srcs)
}
inline void APISequence_OneAPI_AddManyList::_internal_add_srcs(uint32_t value) {
  _impl_.srcs_.Add(value);
}
inline void APISequence_OneAPI_AddManyList::add_srcs(uint32_t value) {
  _internal_add_srcs(value);
  // @@protoc_insertion_point(field_add:OpenFHE.APISequence.OneAPI.AddManyList.srcs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
APISequence_OneAPI_AddManyList::_internal_srcs() const {
  return _impl_.srcs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
APISequence_OneAPI_AddManyList::srcs() const {
  // @@protoc_insertion_point(field_list:OpenFHE.APISequence.OneAPI.AddManyList.srcs)
  return _internal_srcs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
APISequence_OneAPI_AddManyList::_internal_mutable_srcs() {
  return &_impl_.srcs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
APISequence_OneAPI_AddManyList::mutable_srcs() {
  // @@protoc_insertion_point(field_mutable_list:OpenFHE.APISequence.OneAPI.AddManyList.srcs)
  return _internal_mutable_srcs();
}

// -------------------------------------------------------------------

// APISequence_OneAPI_SubTwoList

// uint32 src1 = 1;
inline void APISequence_OneAPI_SubTwoList::clear_src1() {
  _impl_.src1_ = 0u;
}
inline uint32_t APISequence_OneAPI_SubTwoList::_internal_src1() const {
  return _impl_.src1_;
}
inline uint32_t APISequence_OneAPI_SubTwoList::src1() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.SubTwoList.src1)
  return _internal_src1();
}
inline void APISequence_OneAPI_SubTwoList::_internal_set_src1(uint32_t value) {
  
  _impl_.src1_ = value;
}
inline void APISequence_OneAPI_SubTwoList::set_src1(uint32_t value) {
  _internal_set_src1(value);
  // @@protoc_insertion_point(field_set:OpenFHE.APISequence.OneAPI.SubTwoList.src1)
}

// uint32 src2 = 2;
inline void APISequence_OneAPI_SubTwoList::clear_src2() {
  _impl_.src2_ = 0u;
}
inline uint32_t APISequence_OneAPI_SubTwoList::_internal_src2() const {
  return _impl_.src2_;
}
inline uint32_t APISequence_OneAPI_SubTwoList::src2() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.SubTwoList.src2)
  return _internal_src2();
}
inline void APISequence_OneAPI_SubTwoList::_internal_set_src2(uint32_t value) {
  
  _impl_.src2_ = value;
}
inline void APISequence_OneAPI_SubTwoList::set_src2(uint32_t value) {
  _internal_set_src2(value);
  // @@protoc_insertion_point(field_set:OpenFHE.APISequence.OneAPI.SubTwoList.src2)
}

// -------------------------------------------------------------------

// APISequence_OneAPI_MulTwoList

// uint32 src1 = 1;
inline void APISequence_OneAPI_MulTwoList::clear_src1() {
  _impl_.src1_ = 0u;
}
inline uint32_t APISequence_OneAPI_MulTwoList::_internal_src1() const {
  return _impl_.src1_;
}
inline uint32_t APISequence_OneAPI_MulTwoList::src1() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.MulTwoList.src1)
  return _internal_src1();
}
inline void APISequence_OneAPI_MulTwoList::_internal_set_src1(uint32_t value) {
  
  _impl_.src1_ = value;
}
inline void APISequence_OneAPI_MulTwoList::set_src1(uint32_t value) {
  _internal_set_src1(value);
  // @@protoc_insertion_point(field_set:OpenFHE.APISequence.OneAPI.MulTwoList.src1)
}

// uint32 src2 = 2;
inline void APISequence_OneAPI_MulTwoList::clear_src2() {
  _impl_.src2_ = 0u;
}
inline uint32_t APISequence_OneAPI_MulTwoList::_internal_src2() const {
  return _impl_.src2_;
}
inline uint32_t APISequence_OneAPI_MulTwoList::src2() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.MulTwoList.src2)
  return _internal_src2();
}
inline void APISequence_OneAPI_MulTwoList::_internal_set_src2(uint32_t value) {
  
  _impl_.src2_ = value;
}
inline void APISequence_OneAPI_MulTwoList::set_src2(uint32_t value) {
  _internal_set_src2(value);
  // @@protoc_insertion_point(field_set:OpenFHE.APISequence.OneAPI.MulTwoList.src2)
}

// -------------------------------------------------------------------

// APISequence_OneAPI_MulManyList

// repeated uint32 srcs = 1;
inline int APISequence_OneAPI_MulManyList::_internal_srcs_size() const {
  return _impl_.srcs_.size();
}
inline int APISequence_OneAPI_MulManyList::srcs_size() const {
  return _internal_srcs_size();
}
inline void APISequence_OneAPI_MulManyList::clear_srcs() {
  _impl_.srcs_.Clear();
}
inline uint32_t APISequence_OneAPI_MulManyList::_internal_srcs(int index) const {
  return _impl_.srcs_.Get(index);
}
inline uint32_t APISequence_OneAPI_MulManyList::srcs(int index) const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.MulManyList.srcs)
  return _internal_srcs(index);
}
inline void APISequence_OneAPI_MulManyList::set_srcs(int index, uint32_t value) {
  _impl_.srcs_.Set(index, value);
  // @@protoc_insertion_point(field_set:OpenFHE.APISequence.OneAPI.MulManyList.srcs)
}
inline void APISequence_OneAPI_MulManyList::_internal_add_srcs(uint32_t value) {
  _impl_.srcs_.Add(value);
}
inline void APISequence_OneAPI_MulManyList::add_srcs(uint32_t value) {
  _internal_add_srcs(value);
  // @@protoc_insertion_point(field_add:OpenFHE.APISequence.OneAPI.MulManyList.srcs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
APISequence_OneAPI_MulManyList::_internal_srcs() const {
  return _impl_.srcs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
APISequence_OneAPI_MulManyList::srcs() const {
  // @@protoc_insertion_point(field_list:OpenFHE.APISequence.OneAPI.MulManyList.srcs)
  return _internal_srcs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
APISequence_OneAPI_MulManyList::_internal_mutable_srcs() {
  return &_impl_.srcs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
APISequence_OneAPI_MulManyList::mutable_srcs() {
  // @@protoc_insertion_point(field_mutable_list:OpenFHE.APISequence.OneAPI.MulManyList.srcs)
  return _internal_mutable_srcs();
}

// -------------------------------------------------------------------

// APISequence_OneAPI_RotateOneList

// uint32 src = 1;
inline void APISequence_OneAPI_RotateOneList::clear_src() {
  _impl_.src_ = 0u;
}
inline uint32_t APISequence_OneAPI_RotateOneList::_internal_src() const {
  return _impl_.src_;
}
inline uint32_t APISequence_OneAPI_RotateOneList::src() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.RotateOneList.src)
  return _internal_src();
}
inline void APISequence_OneAPI_RotateOneList::_internal_set_src(uint32_t value) {
  
  _impl_.src_ = value;
}
inline void APISequence_OneAPI_RotateOneList::set_src(uint32_t value) {
  _internal_set_src(value);
  // @@protoc_insertion_point(field_set:OpenFHE.APISequence.OneAPI.RotateOneList.src)
}

// int32 index = 2;
inline void APISequence_OneAPI_RotateOneList::clear_index() {
  _impl_.index_ = 0;
}
inline int32_t APISequence_OneAPI_RotateOneList::_internal_index() const {
  return _impl_.index_;
}
inline int32_t APISequence_OneAPI_RotateOneList::index() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.RotateOneList.index)
  return _internal_index();
}
inline void APISequence_OneAPI_RotateOneList::_internal_set_index(int32_t value) {
  
  _impl_.index_ = value;
}
inline void APISequence_OneAPI_RotateOneList::set_index(int32_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:OpenFHE.APISequence.OneAPI.RotateOneList.index)
}

// -------------------------------------------------------------------

// APISequence_OneAPI

// .OpenFHE.APISequence.OneAPI.AddTwoList addTwoList = 1;
inline bool APISequence_OneAPI::_internal_has_addtwolist() const {
  return api_case() == kAddTwoList;
}
inline bool APISequence_OneAPI::has_addtwolist() const {
  return _internal_has_addtwolist();
}
inline void APISequence_OneAPI::set_has_addtwolist() {
  _impl_._oneof_case_[0] = kAddTwoList;
}
inline void APISequence_OneAPI::clear_addtwolist() {
  if (_internal_has_addtwolist()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.api_.addtwolist_;
    }
    clear_has_api();
  }
}
inline ::OpenFHE::APISequence_OneAPI_AddTwoList* APISequence_OneAPI::release_addtwolist() {
  // @@protoc_insertion_point(field_release:OpenFHE.APISequence.OneAPI.addTwoList)
  if (_internal_has_addtwolist()) {
    clear_has_api();
    ::OpenFHE::APISequence_OneAPI_AddTwoList* temp = _impl_.api_.addtwolist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.api_.addtwolist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::OpenFHE::APISequence_OneAPI_AddTwoList& APISequence_OneAPI::_internal_addtwolist() const {
  return _internal_has_addtwolist()
      ? *_impl_.api_.addtwolist_
      : reinterpret_cast< ::OpenFHE::APISequence_OneAPI_AddTwoList&>(::OpenFHE::_APISequence_OneAPI_AddTwoList_default_instance_);
}
inline const ::OpenFHE::APISequence_OneAPI_AddTwoList& APISequence_OneAPI::addtwolist() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.addTwoList)
  return _internal_addtwolist();
}
inline ::OpenFHE::APISequence_OneAPI_AddTwoList* APISequence_OneAPI::unsafe_arena_release_addtwolist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:OpenFHE.APISequence.OneAPI.addTwoList)
  if (_internal_has_addtwolist()) {
    clear_has_api();
    ::OpenFHE::APISequence_OneAPI_AddTwoList* temp = _impl_.api_.addtwolist_;
    _impl_.api_.addtwolist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void APISequence_OneAPI::unsafe_arena_set_allocated_addtwolist(::OpenFHE::APISequence_OneAPI_AddTwoList* addtwolist) {
  clear_api();
  if (addtwolist) {
    set_has_addtwolist();
    _impl_.api_.addtwolist_ = addtwolist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OpenFHE.APISequence.OneAPI.addTwoList)
}
inline ::OpenFHE::APISequence_OneAPI_AddTwoList* APISequence_OneAPI::_internal_mutable_addtwolist() {
  if (!_internal_has_addtwolist()) {
    clear_api();
    set_has_addtwolist();
    _impl_.api_.addtwolist_ = CreateMaybeMessage< ::OpenFHE::APISequence_OneAPI_AddTwoList >(GetArenaForAllocation());
  }
  return _impl_.api_.addtwolist_;
}
inline ::OpenFHE::APISequence_OneAPI_AddTwoList* APISequence_OneAPI::mutable_addtwolist() {
  ::OpenFHE::APISequence_OneAPI_AddTwoList* _msg = _internal_mutable_addtwolist();
  // @@protoc_insertion_point(field_mutable:OpenFHE.APISequence.OneAPI.addTwoList)
  return _msg;
}

// .OpenFHE.APISequence.OneAPI.AddManyList addManyList = 2;
inline bool APISequence_OneAPI::_internal_has_addmanylist() const {
  return api_case() == kAddManyList;
}
inline bool APISequence_OneAPI::has_addmanylist() const {
  return _internal_has_addmanylist();
}
inline void APISequence_OneAPI::set_has_addmanylist() {
  _impl_._oneof_case_[0] = kAddManyList;
}
inline void APISequence_OneAPI::clear_addmanylist() {
  if (_internal_has_addmanylist()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.api_.addmanylist_;
    }
    clear_has_api();
  }
}
inline ::OpenFHE::APISequence_OneAPI_AddManyList* APISequence_OneAPI::release_addmanylist() {
  // @@protoc_insertion_point(field_release:OpenFHE.APISequence.OneAPI.addManyList)
  if (_internal_has_addmanylist()) {
    clear_has_api();
    ::OpenFHE::APISequence_OneAPI_AddManyList* temp = _impl_.api_.addmanylist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.api_.addmanylist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::OpenFHE::APISequence_OneAPI_AddManyList& APISequence_OneAPI::_internal_addmanylist() const {
  return _internal_has_addmanylist()
      ? *_impl_.api_.addmanylist_
      : reinterpret_cast< ::OpenFHE::APISequence_OneAPI_AddManyList&>(::OpenFHE::_APISequence_OneAPI_AddManyList_default_instance_);
}
inline const ::OpenFHE::APISequence_OneAPI_AddManyList& APISequence_OneAPI::addmanylist() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.addManyList)
  return _internal_addmanylist();
}
inline ::OpenFHE::APISequence_OneAPI_AddManyList* APISequence_OneAPI::unsafe_arena_release_addmanylist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:OpenFHE.APISequence.OneAPI.addManyList)
  if (_internal_has_addmanylist()) {
    clear_has_api();
    ::OpenFHE::APISequence_OneAPI_AddManyList* temp = _impl_.api_.addmanylist_;
    _impl_.api_.addmanylist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void APISequence_OneAPI::unsafe_arena_set_allocated_addmanylist(::OpenFHE::APISequence_OneAPI_AddManyList* addmanylist) {
  clear_api();
  if (addmanylist) {
    set_has_addmanylist();
    _impl_.api_.addmanylist_ = addmanylist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OpenFHE.APISequence.OneAPI.addManyList)
}
inline ::OpenFHE::APISequence_OneAPI_AddManyList* APISequence_OneAPI::_internal_mutable_addmanylist() {
  if (!_internal_has_addmanylist()) {
    clear_api();
    set_has_addmanylist();
    _impl_.api_.addmanylist_ = CreateMaybeMessage< ::OpenFHE::APISequence_OneAPI_AddManyList >(GetArenaForAllocation());
  }
  return _impl_.api_.addmanylist_;
}
inline ::OpenFHE::APISequence_OneAPI_AddManyList* APISequence_OneAPI::mutable_addmanylist() {
  ::OpenFHE::APISequence_OneAPI_AddManyList* _msg = _internal_mutable_addmanylist();
  // @@protoc_insertion_point(field_mutable:OpenFHE.APISequence.OneAPI.addManyList)
  return _msg;
}

// .OpenFHE.APISequence.OneAPI.SubTwoList subTwoList = 3;
inline bool APISequence_OneAPI::_internal_has_subtwolist() const {
  return api_case() == kSubTwoList;
}
inline bool APISequence_OneAPI::has_subtwolist() const {
  return _internal_has_subtwolist();
}
inline void APISequence_OneAPI::set_has_subtwolist() {
  _impl_._oneof_case_[0] = kSubTwoList;
}
inline void APISequence_OneAPI::clear_subtwolist() {
  if (_internal_has_subtwolist()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.api_.subtwolist_;
    }
    clear_has_api();
  }
}
inline ::OpenFHE::APISequence_OneAPI_SubTwoList* APISequence_OneAPI::release_subtwolist() {
  // @@protoc_insertion_point(field_release:OpenFHE.APISequence.OneAPI.subTwoList)
  if (_internal_has_subtwolist()) {
    clear_has_api();
    ::OpenFHE::APISequence_OneAPI_SubTwoList* temp = _impl_.api_.subtwolist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.api_.subtwolist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::OpenFHE::APISequence_OneAPI_SubTwoList& APISequence_OneAPI::_internal_subtwolist() const {
  return _internal_has_subtwolist()
      ? *_impl_.api_.subtwolist_
      : reinterpret_cast< ::OpenFHE::APISequence_OneAPI_SubTwoList&>(::OpenFHE::_APISequence_OneAPI_SubTwoList_default_instance_);
}
inline const ::OpenFHE::APISequence_OneAPI_SubTwoList& APISequence_OneAPI::subtwolist() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.subTwoList)
  return _internal_subtwolist();
}
inline ::OpenFHE::APISequence_OneAPI_SubTwoList* APISequence_OneAPI::unsafe_arena_release_subtwolist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:OpenFHE.APISequence.OneAPI.subTwoList)
  if (_internal_has_subtwolist()) {
    clear_has_api();
    ::OpenFHE::APISequence_OneAPI_SubTwoList* temp = _impl_.api_.subtwolist_;
    _impl_.api_.subtwolist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void APISequence_OneAPI::unsafe_arena_set_allocated_subtwolist(::OpenFHE::APISequence_OneAPI_SubTwoList* subtwolist) {
  clear_api();
  if (subtwolist) {
    set_has_subtwolist();
    _impl_.api_.subtwolist_ = subtwolist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OpenFHE.APISequence.OneAPI.subTwoList)
}
inline ::OpenFHE::APISequence_OneAPI_SubTwoList* APISequence_OneAPI::_internal_mutable_subtwolist() {
  if (!_internal_has_subtwolist()) {
    clear_api();
    set_has_subtwolist();
    _impl_.api_.subtwolist_ = CreateMaybeMessage< ::OpenFHE::APISequence_OneAPI_SubTwoList >(GetArenaForAllocation());
  }
  return _impl_.api_.subtwolist_;
}
inline ::OpenFHE::APISequence_OneAPI_SubTwoList* APISequence_OneAPI::mutable_subtwolist() {
  ::OpenFHE::APISequence_OneAPI_SubTwoList* _msg = _internal_mutable_subtwolist();
  // @@protoc_insertion_point(field_mutable:OpenFHE.APISequence.OneAPI.subTwoList)
  return _msg;
}

// .OpenFHE.APISequence.OneAPI.MulTwoList mulTwoList = 4;
inline bool APISequence_OneAPI::_internal_has_multwolist() const {
  return api_case() == kMulTwoList;
}
inline bool APISequence_OneAPI::has_multwolist() const {
  return _internal_has_multwolist();
}
inline void APISequence_OneAPI::set_has_multwolist() {
  _impl_._oneof_case_[0] = kMulTwoList;
}
inline void APISequence_OneAPI::clear_multwolist() {
  if (_internal_has_multwolist()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.api_.multwolist_;
    }
    clear_has_api();
  }
}
inline ::OpenFHE::APISequence_OneAPI_MulTwoList* APISequence_OneAPI::release_multwolist() {
  // @@protoc_insertion_point(field_release:OpenFHE.APISequence.OneAPI.mulTwoList)
  if (_internal_has_multwolist()) {
    clear_has_api();
    ::OpenFHE::APISequence_OneAPI_MulTwoList* temp = _impl_.api_.multwolist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.api_.multwolist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::OpenFHE::APISequence_OneAPI_MulTwoList& APISequence_OneAPI::_internal_multwolist() const {
  return _internal_has_multwolist()
      ? *_impl_.api_.multwolist_
      : reinterpret_cast< ::OpenFHE::APISequence_OneAPI_MulTwoList&>(::OpenFHE::_APISequence_OneAPI_MulTwoList_default_instance_);
}
inline const ::OpenFHE::APISequence_OneAPI_MulTwoList& APISequence_OneAPI::multwolist() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.mulTwoList)
  return _internal_multwolist();
}
inline ::OpenFHE::APISequence_OneAPI_MulTwoList* APISequence_OneAPI::unsafe_arena_release_multwolist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:OpenFHE.APISequence.OneAPI.mulTwoList)
  if (_internal_has_multwolist()) {
    clear_has_api();
    ::OpenFHE::APISequence_OneAPI_MulTwoList* temp = _impl_.api_.multwolist_;
    _impl_.api_.multwolist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void APISequence_OneAPI::unsafe_arena_set_allocated_multwolist(::OpenFHE::APISequence_OneAPI_MulTwoList* multwolist) {
  clear_api();
  if (multwolist) {
    set_has_multwolist();
    _impl_.api_.multwolist_ = multwolist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OpenFHE.APISequence.OneAPI.mulTwoList)
}
inline ::OpenFHE::APISequence_OneAPI_MulTwoList* APISequence_OneAPI::_internal_mutable_multwolist() {
  if (!_internal_has_multwolist()) {
    clear_api();
    set_has_multwolist();
    _impl_.api_.multwolist_ = CreateMaybeMessage< ::OpenFHE::APISequence_OneAPI_MulTwoList >(GetArenaForAllocation());
  }
  return _impl_.api_.multwolist_;
}
inline ::OpenFHE::APISequence_OneAPI_MulTwoList* APISequence_OneAPI::mutable_multwolist() {
  ::OpenFHE::APISequence_OneAPI_MulTwoList* _msg = _internal_mutable_multwolist();
  // @@protoc_insertion_point(field_mutable:OpenFHE.APISequence.OneAPI.mulTwoList)
  return _msg;
}

// .OpenFHE.APISequence.OneAPI.MulManyList mulManyList = 5;
inline bool APISequence_OneAPI::_internal_has_mulmanylist() const {
  return api_case() == kMulManyList;
}
inline bool APISequence_OneAPI::has_mulmanylist() const {
  return _internal_has_mulmanylist();
}
inline void APISequence_OneAPI::set_has_mulmanylist() {
  _impl_._oneof_case_[0] = kMulManyList;
}
inline void APISequence_OneAPI::clear_mulmanylist() {
  if (_internal_has_mulmanylist()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.api_.mulmanylist_;
    }
    clear_has_api();
  }
}
inline ::OpenFHE::APISequence_OneAPI_MulManyList* APISequence_OneAPI::release_mulmanylist() {
  // @@protoc_insertion_point(field_release:OpenFHE.APISequence.OneAPI.mulManyList)
  if (_internal_has_mulmanylist()) {
    clear_has_api();
    ::OpenFHE::APISequence_OneAPI_MulManyList* temp = _impl_.api_.mulmanylist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.api_.mulmanylist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::OpenFHE::APISequence_OneAPI_MulManyList& APISequence_OneAPI::_internal_mulmanylist() const {
  return _internal_has_mulmanylist()
      ? *_impl_.api_.mulmanylist_
      : reinterpret_cast< ::OpenFHE::APISequence_OneAPI_MulManyList&>(::OpenFHE::_APISequence_OneAPI_MulManyList_default_instance_);
}
inline const ::OpenFHE::APISequence_OneAPI_MulManyList& APISequence_OneAPI::mulmanylist() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.mulManyList)
  return _internal_mulmanylist();
}
inline ::OpenFHE::APISequence_OneAPI_MulManyList* APISequence_OneAPI::unsafe_arena_release_mulmanylist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:OpenFHE.APISequence.OneAPI.mulManyList)
  if (_internal_has_mulmanylist()) {
    clear_has_api();
    ::OpenFHE::APISequence_OneAPI_MulManyList* temp = _impl_.api_.mulmanylist_;
    _impl_.api_.mulmanylist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void APISequence_OneAPI::unsafe_arena_set_allocated_mulmanylist(::OpenFHE::APISequence_OneAPI_MulManyList* mulmanylist) {
  clear_api();
  if (mulmanylist) {
    set_has_mulmanylist();
    _impl_.api_.mulmanylist_ = mulmanylist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OpenFHE.APISequence.OneAPI.mulManyList)
}
inline ::OpenFHE::APISequence_OneAPI_MulManyList* APISequence_OneAPI::_internal_mutable_mulmanylist() {
  if (!_internal_has_mulmanylist()) {
    clear_api();
    set_has_mulmanylist();
    _impl_.api_.mulmanylist_ = CreateMaybeMessage< ::OpenFHE::APISequence_OneAPI_MulManyList >(GetArenaForAllocation());
  }
  return _impl_.api_.mulmanylist_;
}
inline ::OpenFHE::APISequence_OneAPI_MulManyList* APISequence_OneAPI::mutable_mulmanylist() {
  ::OpenFHE::APISequence_OneAPI_MulManyList* _msg = _internal_mutable_mulmanylist();
  // @@protoc_insertion_point(field_mutable:OpenFHE.APISequence.OneAPI.mulManyList)
  return _msg;
}

// .OpenFHE.APISequence.OneAPI.RotateOneList rotateOneList = 6;
inline bool APISequence_OneAPI::_internal_has_rotateonelist() const {
  return api_case() == kRotateOneList;
}
inline bool APISequence_OneAPI::has_rotateonelist() const {
  return _internal_has_rotateonelist();
}
inline void APISequence_OneAPI::set_has_rotateonelist() {
  _impl_._oneof_case_[0] = kRotateOneList;
}
inline void APISequence_OneAPI::clear_rotateonelist() {
  if (_internal_has_rotateonelist()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.api_.rotateonelist_;
    }
    clear_has_api();
  }
}
inline ::OpenFHE::APISequence_OneAPI_RotateOneList* APISequence_OneAPI::release_rotateonelist() {
  // @@protoc_insertion_point(field_release:OpenFHE.APISequence.OneAPI.rotateOneList)
  if (_internal_has_rotateonelist()) {
    clear_has_api();
    ::OpenFHE::APISequence_OneAPI_RotateOneList* temp = _impl_.api_.rotateonelist_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.api_.rotateonelist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::OpenFHE::APISequence_OneAPI_RotateOneList& APISequence_OneAPI::_internal_rotateonelist() const {
  return _internal_has_rotateonelist()
      ? *_impl_.api_.rotateonelist_
      : reinterpret_cast< ::OpenFHE::APISequence_OneAPI_RotateOneList&>(::OpenFHE::_APISequence_OneAPI_RotateOneList_default_instance_);
}
inline const ::OpenFHE::APISequence_OneAPI_RotateOneList& APISequence_OneAPI::rotateonelist() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.rotateOneList)
  return _internal_rotateonelist();
}
inline ::OpenFHE::APISequence_OneAPI_RotateOneList* APISequence_OneAPI::unsafe_arena_release_rotateonelist() {
  // @@protoc_insertion_point(field_unsafe_arena_release:OpenFHE.APISequence.OneAPI.rotateOneList)
  if (_internal_has_rotateonelist()) {
    clear_has_api();
    ::OpenFHE::APISequence_OneAPI_RotateOneList* temp = _impl_.api_.rotateonelist_;
    _impl_.api_.rotateonelist_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void APISequence_OneAPI::unsafe_arena_set_allocated_rotateonelist(::OpenFHE::APISequence_OneAPI_RotateOneList* rotateonelist) {
  clear_api();
  if (rotateonelist) {
    set_has_rotateonelist();
    _impl_.api_.rotateonelist_ = rotateonelist;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:OpenFHE.APISequence.OneAPI.rotateOneList)
}
inline ::OpenFHE::APISequence_OneAPI_RotateOneList* APISequence_OneAPI::_internal_mutable_rotateonelist() {
  if (!_internal_has_rotateonelist()) {
    clear_api();
    set_has_rotateonelist();
    _impl_.api_.rotateonelist_ = CreateMaybeMessage< ::OpenFHE::APISequence_OneAPI_RotateOneList >(GetArenaForAllocation());
  }
  return _impl_.api_.rotateonelist_;
}
inline ::OpenFHE::APISequence_OneAPI_RotateOneList* APISequence_OneAPI::mutable_rotateonelist() {
  ::OpenFHE::APISequence_OneAPI_RotateOneList* _msg = _internal_mutable_rotateonelist();
  // @@protoc_insertion_point(field_mutable:OpenFHE.APISequence.OneAPI.rotateOneList)
  return _msg;
}

// uint32 dst = 7;
inline void APISequence_OneAPI::clear_dst() {
  _impl_.dst_ = 0u;
}
inline uint32_t APISequence_OneAPI::_internal_dst() const {
  return _impl_.dst_;
}
inline uint32_t APISequence_OneAPI::dst() const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.OneAPI.dst)
  return _internal_dst();
}
inline void APISequence_OneAPI::_internal_set_dst(uint32_t value) {
  
  _impl_.dst_ = value;
}
inline void APISequence_OneAPI::set_dst(uint32_t value) {
  _internal_set_dst(value);
  // @@protoc_insertion_point(field_set:OpenFHE.APISequence.OneAPI.dst)
}

inline bool APISequence_OneAPI::has_api() const {
  return api_case() != API_NOT_SET;
}
inline void APISequence_OneAPI::clear_has_api() {
  _impl_._oneof_case_[0] = API_NOT_SET;
}
inline APISequence_OneAPI::ApiCase APISequence_OneAPI::api_case() const {
  return APISequence_OneAPI::ApiCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// APISequence

// repeated .OpenFHE.APISequence.OneAPI apiList = 1;
inline int APISequence::_internal_apilist_size() const {
  return _impl_.apilist_.size();
}
inline int APISequence::apilist_size() const {
  return _internal_apilist_size();
}
inline void APISequence::clear_apilist() {
  _impl_.apilist_.Clear();
}
inline ::OpenFHE::APISequence_OneAPI* APISequence::mutable_apilist(int index) {
  // @@protoc_insertion_point(field_mutable:OpenFHE.APISequence.apiList)
  return _impl_.apilist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenFHE::APISequence_OneAPI >*
APISequence::mutable_apilist() {
  // @@protoc_insertion_point(field_mutable_list:OpenFHE.APISequence.apiList)
  return &_impl_.apilist_;
}
inline const ::OpenFHE::APISequence_OneAPI& APISequence::_internal_apilist(int index) const {
  return _impl_.apilist_.Get(index);
}
inline const ::OpenFHE::APISequence_OneAPI& APISequence::apilist(int index) const {
  // @@protoc_insertion_point(field_get:OpenFHE.APISequence.apiList)
  return _internal_apilist(index);
}
inline ::OpenFHE::APISequence_OneAPI* APISequence::_internal_add_apilist() {
  return _impl_.apilist_.Add();
}
inline ::OpenFHE::APISequence_OneAPI* APISequence::add_apilist() {
  ::OpenFHE::APISequence_OneAPI* _add = _internal_add_apilist();
  // @@protoc_insertion_point(field_add:OpenFHE.APISequence.apiList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::OpenFHE::APISequence_OneAPI >&
APISequence::apilist() const {
  // @@protoc_insertion_point(field_list:OpenFHE.APISequence.apiList)
  return _impl_.apilist_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace OpenFHE

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::OpenFHE::SecretKeyDist> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenFHE::SecretKeyDist>() {
  return ::OpenFHE::SecretKeyDist_descriptor();
}
template <> struct is_proto_enum< ::OpenFHE::ScalingTechnique> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenFHE::ScalingTechnique>() {
  return ::OpenFHE::ScalingTechnique_descriptor();
}
template <> struct is_proto_enum< ::OpenFHE::KeySwitchTechnique> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenFHE::KeySwitchTechnique>() {
  return ::OpenFHE::KeySwitchTechnique_descriptor();
}
template <> struct is_proto_enum< ::OpenFHE::SecurityLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenFHE::SecurityLevel>() {
  return ::OpenFHE::SecurityLevel_descriptor();
}
template <> struct is_proto_enum< ::OpenFHE::EncryptionTechnique> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenFHE::EncryptionTechnique>() {
  return ::OpenFHE::EncryptionTechnique_descriptor();
}
template <> struct is_proto_enum< ::OpenFHE::MultiplicationTechnique> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenFHE::MultiplicationTechnique>() {
  return ::OpenFHE::MultiplicationTechnique_descriptor();
}
template <> struct is_proto_enum< ::OpenFHE::ProxyReEncryptionMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenFHE::ProxyReEncryptionMode>() {
  return ::OpenFHE::ProxyReEncryptionMode_descriptor();
}
template <> struct is_proto_enum< ::OpenFHE::ExecutionMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenFHE::ExecutionMode>() {
  return ::OpenFHE::ExecutionMode_descriptor();
}
template <> struct is_proto_enum< ::OpenFHE::DecryptionNoiseMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenFHE::DecryptionNoiseMode>() {
  return ::OpenFHE::DecryptionNoiseMode_descriptor();
}
template <> struct is_proto_enum< ::OpenFHE::MultipartyMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::OpenFHE::MultipartyMode>() {
  return ::OpenFHE::MultipartyMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_proto_2fopenfhe_5fbgv_2eproto
